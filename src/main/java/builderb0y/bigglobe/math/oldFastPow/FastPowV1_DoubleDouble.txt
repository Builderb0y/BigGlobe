package builderb0y.bigglobe.math;

import java.io.PrintWriter;
import java.lang.invoke.*;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.DoubleUnaryOperator;

import it.unimi.dsi.fastutil.doubles.Double2ObjectMap;
import it.unimi.dsi.fastutil.doubles.Double2ObjectOpenHashMap;
import org.jetbrains.annotations.TestOnly;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.Type;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceClassVisitor;

import builderb0y.autocodec.util.AutoCodecUtil;
import builderb0y.scripting.bytecode.*;
import builderb0y.scripting.bytecode.tree.InsnTree;
import builderb0y.scripting.bytecode.tree.instructions.ConstantInsnTree;
import builderb0y.scripting.bytecode.tree.instructions.ReturnInsnTree;

/**
{@link Math#pow(double, double)} is slow.
granted, it's *roughly* O(1), but some specific powers can be done MUCH faster.
pow(x, 2.0) is actually the same speed as x * x due to that power being special-cased.
however, other powers are still problematic.
for example, x * x * x is faster than pow(x, 3.0).
x * x * x * x is faster than pow(x, 4.0), but pow2(pow2(x)) is even faster than x * x * x * x.
binary arithmetic can be used to reduce any integer power into a few multiply and square operations.

fractional exponents are a bit harder, but they're still possible too.
assuming your hardware supports it, {@link Math#sqrt(double)} is faster than pow(x, 0.5).
likewise, sqrt(sqrt(x)) is faster than pow(x, 0.25).

combining the two are also possible, because exponents can be re-arranged:
	pow(x, a) * pow(x, b) = pow(x, a + b)
	pow(pow(x, a), b) = pow(x, a * b)
using these two rules, we can re-write certain fractional exponents too:
	pow(x, 1.5) = x * sqrt(x).
	pow(x, 1.25) = x * sqrt(sqrt(x)).
	pow(x, 0.75) = sqrt(x) * sqrt(sqrt(x)).
		side note: sqrt(x) appears twice in the above example,
		but rest assured that the operators produced by
		this class will only compute it once at runtime.
	pow(x, 1.75) = x * sqrt(x) * sqrt(sqrt(x))
		sqrt(x) is only computed once here too.
this process is repeatable for any binary fraction (and therefore all floating-point values).
however, doing so for powers like 0.3 would result in a *lot* of {@link Math#sqrt(double)} operations.
{@link Math#sqrt(double)} is fast on most modern hardware, but it still adds up.
this class therefore allows a configurable limit on the maximum
number of operations before falling back on {@link Math#pow(double, double)}.

note: computing the power differently than {@link Math#pow(double, double)} does implies
that the results obtained may be different than what {@link Math#pow(double, double)}
would give you. in most cases, results are only off by a few ulps max,
but at the time of writing this, certain special cases are not handled correctly yet.
for example: pow(-infinity, -0.5) would return 0.0D, but the equivalent DoublePowOperator
would return NaN. this is because x ^ -0.5 = 1.0 / sqrt(x), and sqrt(-infinity) is NaN.
such special cases should not be relied on, and this bug may be fixed in the future.
in general, DoublePowOperator's are only intended to handle finite inputs {@link Double#isFinite(double)},
even if the operator itself can raise its input to a non-finite power.

note: the act of creating these operators in the first place is also slow.
much slower than {@link Math#pow(double, double)} in almost all cases.
this class should therefore only be used if you intend
to raise a LOT of numbers to one very specific (usually constant) power.
if the power is not constant, then {@link Math#pow(double, double)} should be used instead.
*/
public class DoubleFastPow {

	/**
	a {@link DoubleUnaryOperator} which raises its argument to a specific power.
	operators are created by {@link #makePowFunction(double)},
	and the power is configurable there. additionally, the power an
	operator was created with can be queried via {@link #getPower()}.

	operators generated by {@link #makePowFunction(double)} will be generated at runtime,
	and given their own bytecode to compute the argument raised
	to the associated power in as few instructions as possible.
	this ensures that invoking {@link #applyAsDouble(double)}
	has an overhead of at most 1 megamorphic call site,
	plus the operations involved in actually computing the requested value.
	*/
	public static abstract class DoublePowOperator implements DoubleUnaryOperator {

		public abstract double getPower();
	}

	public static record CacheEntry(
		MethodHandles.Lookup lookup,
		DoublePowOperator operator,
		CallSite callSite
	) {

		public Class<? extends DoublePowOperator> clazz() {
			return this.lookup.lookupClass().asSubclass(DoublePowOperator.class);
		}

		public MethodHandle handle() {
			return this.callSite.getTarget();
		}
	}
	public static final Double2ObjectMap<CacheEntry> CACHE = new Double2ObjectOpenHashMap<>(16);
	public static final int maxMultiplications = 8, maxSquareRoots = 2;

	public int remainingMultiplications, remainingSquareRoots;
	public boolean useCache;

	public DoubleFastPow(int remainingMultiplications, int remainingSquareRoots, boolean useCache) {
		this.remainingMultiplications = remainingMultiplications;
		this.remainingSquareRoots = remainingSquareRoots;
		this.useCache = useCache;
	}

	/**
	static factory method which provides a "best guess"
	for a reasonable number of operations to allow.
	*/
	public static DoubleFastPow bestGuess() {
		return new DoubleFastPow(maxMultiplications, maxSquareRoots, true);
	}

	/**
	returns a DoubleFastPow which allows unlimited multiply and sqrt operations.
	primarily useful for testing.
	*/
	@TestOnly
	public static DoubleFastPow unlimitedOperations() {
		return new DoubleFastPow(Integer.MAX_VALUE, Integer.MAX_VALUE, false);
	}

	public static DoubleFastPow customOperations(int multiplications, int squareRoots) {
		return new DoubleFastPow(multiplications, squareRoots, false);
	}

	public void checkRemaining() {
		if (this.remainingMultiplications <= 0 && this.remainingSquareRoots <= 0) {
			throw new IllegalStateException("Set remaining operations before calling makePowFunction()");
		}
	}

	public boolean decrementMultiplications() {
		return --this.remainingMultiplications < 0;
	}

	public boolean decrementSquareRoots() {
		return --this.remainingSquareRoots < 0;
	}

	/** creates an operator for ANY power. this is the primary method of this class. */
	public DoublePowOperator makePowFunction(final double power) {
		return this.getCacheEntry(power).operator;
	}

	/**
	creates a MethodHandle whose {@link MethodHandle#type()}
	is (double)double, and which behaves like the implementation of
	{@link DoublePowOperator#applyAsDouble(double)} for the given power.
	*/
	public MethodHandle makePowMethodHandle(final double power) {
		return this.getCacheEntry(power).handle();
	}

	public static CallSite makePowCallSite(final double power) {
		return bestGuess().getCacheEntry(power).callSite();
	}

	public CacheEntry getCacheEntry(final double power) {
		if (this.useCache) {
			synchronized (CACHE) {
				CacheEntry entry = CACHE.get(power);
				if (entry != null) return entry;
				entry = this.makeCacheEntry(power);
				CACHE.put(power, entry);
				return entry;
			}
		}
		else {
			return this.makeCacheEntry(power);
		}
	}

	public CacheEntry makeCacheEntry(final double power) {
		try {
			MethodHandles.Lookup lookup = this.makeIntermediateRepresentation(power).compile(power);
			Class<? extends DoublePowOperator> clazz = lookup.lookupClass().asSubclass(DoublePowOperator.class);
			DoublePowOperator operator = (DoublePowOperator)(lookup.findConstructor(clazz, MethodType.methodType(void.class)).invoke());
			MethodHandle handle = lookup.findStatic(clazz, "pow", MethodType.methodType(double.class, double.class));
			CallSite callSite = new ConstantCallSite(handle);
			return new CacheEntry(lookup, operator, callSite);
		}
		catch (Throwable throwable) {
			throw AutoCodecUtil.rethrow(throwable);
		}
	}

	@SuppressWarnings("ExplicitArgumentCanBeLambda")
	public IntermediateRepresentation makeIntermediateRepresentation(final double power) {
		this.checkRemaining();
		if (power > 0.0D) return this.makeNormalPower(power).orElse(new DefaultIR(power));
		if (power < 0.0D) return this.makeNormalPower(-power).<IntermediateRepresentation>map(ReciprocalIR::new).orElse(new DefaultIR(power));
		if (power == 0.0D) return ZeroIR.INSTANCE;
		if (Double.isNaN(power)) return NaNIR.INSTANCE;
		throw new AssertionError("power is not greater than 0, less than 0, equal to 0, or NaN: " + power);
	}

	/** creates an intermediate representation for powers which are > 0. */
	public Optional<IntermediateRepresentation> makeNormalPower(final double power) {
		assert power > 0.0D : "power > 0.0D was false: power was " + power;

		int intTarget = (int)(power);
		double fracTarget = power - intTarget;

		//the only way for fracTarget to be >= 1.0 is
		//if power is larger than Integer.MAX_VALUE.
		//we treat all such powers as effectively infinite.
		if (fracTarget >= 1.0D) return Optional.of(InfinityIR.INSTANCE);

		if (fracTarget == 0.0D) switch (intTarget) { //power is an integer
			case 0: throw new AssertionError("intTarget and fracTarget are both 0, power was " + power);
			case 1: return Optional.of(IdentityIR.INSTANCE);
			default: return this.makeIntPower(intTarget);
		}
		else { //power is not an integer
			Optional<IntermediateRepresentation> fracPower = this.makeFracPower(fracTarget);
			switch (intTarget) {
				case 0: return fracPower;
				case 1: return fracPower.map(ExtraMultiplyIR::new);
				default: {
					return fracPower.flatMap(fracOperator -> {
						return this.makeIntPower(intTarget).map(intOperator -> {
							return new ProductIR(intOperator, fracOperator);
						});
					});
				}
			}
		}
	}

	/** creates an intermediate representation for powers which are an integer greater than 1. */
	public Optional<IntermediateRepresentation> makeIntPower(final int power) {
		assert power > 1 : "power > 1 was false: power was: " + power;
		int bits = 31 - Integer.numberOfLeadingZeros(power);
		assert bits > 0 : "bits > 0 was false: power was " + power + ", bits was " + bits;
		IntermediateRepresentation operator = IdentityIR.INSTANCE;
		while (bits-- != 0) {
			if (this.decrementMultiplications()) return Optional.empty();
			//operator = operator.andThen(SquareIR.INSTANCE);
			operator = new SquareIR(operator);
			if ((power & (1 << bits)) != 0) {
				if (this.decrementMultiplications()) return Optional.empty();
				operator = new ExtraMultiplyIR(operator);
			}
		}
		assert operator != IdentityIR.INSTANCE : "int condition was IDENTITY, power was " + power;
		return Optional.of(operator);
	}

	/** creates an intermediate representation for powers which are in the range (0, 1). */
	public Optional<IntermediateRepresentation> makeFracPower(final double power) {
		assert power > 0.0D && power < 1.0D : "power > 0.0D && power < 1.0D was false: power was " + power;
		double power2 = power * 2.0D;
		if (this.decrementSquareRoots()) return Optional.empty();
		if (power2 > 1.0D) {
			if (this.decrementMultiplications()) return Optional.empty();
			return this.makeFracPower(power2 - 1.0D).map(ExtraMultiplyIR::new).map(SqrtIR.INSTANCE::andThen);
		}
		else if (power2 < 1.0D) {
			return this.makeFracPower(power2).map(SqrtIR.INSTANCE::andThen);
		}
		else {
			return Optional.of(SqrtIR.INSTANCE);
		}
	}

	/**
	represents the order of operations to perform in order to raise a number to a requested power.
	subclasses of IntermediateRepresentation correspond to different operations.
	for example, squaring a number with {@link SquareIR}, or square rooting it with {@link SqrtIR}.
	IntermediateRepresentation's can be converted into actual operators
	*/
	public static interface IntermediateRepresentation extends InsnTree {

		/**
		if true, the bytecode of all generated {@link DoublePowOperator}'s
		will be printed to {@link System#out}.
		*/
		public static final boolean DEBUG = false;

		/**
		keeps track of the number of {@link DoublePowOperator}'s which have been created so far.
		this ensures that the backing class generated for each one has a unique name.
		*/
		public static final AtomicInteger COUNTER = new AtomicInteger();

		public default void compileMethod(ClassCompileContext clazz, String name, int access) {
			MethodCompileContext method = clazz.newMethod(access, name, "(D)D");
			method.scopes.pushScope();
			if (!method.info.isStatic()) method.addThis();
			method.newParameter("operand", Type.DOUBLE_TYPE);
			this.emitInitialLoadInstructions(method);
			new ReturnInsnTree(this).emitBytecode(method);
			method.scopes.popScope();
		}

		public default MethodHandles.Lookup compile(final double power) {
			String className = Type.getInternalName(DoubleFastPow.class) + "$Generated$" + COUNTER.getAndIncrement();
			ClassInfo superClass = ClassInfo.of(DoublePowOperator.class);
			ClassCompileContext clazz = new ClassCompileContext(
				ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,
				ClassType.CLASS,
				className,
				superClass,
				ClassInfo.ARRAY_FACTORY.empty()
			);

			clazz.addNoArgConstructor(ACC_PUBLIC);

			this.compileMethod(clazz, "applyAsDouble", ACC_PUBLIC);
			this.compileMethod(clazz, "pow", ACC_PUBLIC | ACC_STATIC);

			MethodCompileContext method;
			method = clazz.newMethod(ACC_PUBLIC, "getPower", "()D");
			method.scopes.pushScope();
			method.addThis();
			new ReturnInsnTree(new ConstantInsnTree(power)).emitBytecode(method);
			method.scopes.popScope();

			method = clazz.newMethod(ACC_PUBLIC, "toString", "()Ljava/lang/String;");
			method.scopes.pushScope();
			method.addThis();
			new ReturnInsnTree(new ConstantInsnTree("DoublePowOperator for power " + power)).emitBytecode(method);
			method.scopes.popScope();

			byte[] bytes = clazz.toByteArray();
			if (DEBUG) {
				System.out.println("DoublePowOperator created with power " + power + ':');
				TraceClassVisitor traceClassVisitor = new TraceClassVisitor(null, new Textifier(), new PrintWriter(System.out));
				new ClassReader(bytes).accept(traceClassVisitor, 0);
			}
			try {
				return MethodHandles.lookup().defineHiddenClass(bytes, false);
			}
			catch (IllegalAccessException exception) {
				throw AutoCodecUtil.rethrow(exception);
			}
		}

		public default void emitInitialLoadInstructions(MethodCompileContext context) {
			context.node.visitVarInsn(DLOAD, context.findParameter("operand").index);
		}

		public abstract void emitBytecode(MethodCompileContext method);

		public default IntermediateRepresentation andThen(IntermediateRepresentation after) {
			return new ComposeIR(this, after);
		}

		public default IntermediateRepresentation compose(IntermediateRepresentation before) {
			return new ComposeIR(before, this);
		}

		@Override
		public default Type getType() {
			return Type.DOUBLE_TYPE;
		}
	}

	public static class ComposeIR implements IntermediateRepresentation {

		public final IntermediateRepresentation inner, outer;

		public ComposeIR(IntermediateRepresentation inner, IntermediateRepresentation outer) {
			this.inner = inner;
			this.outer = outer;
		}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			this.inner.emitBytecode(method);
			this.outer.emitBytecode(method);
		}
	}

	public static class SquareIR implements IntermediateRepresentation {

		public final IntermediateRepresentation previous;

		public SquareIR(IntermediateRepresentation previous) {
			this.previous = previous;
		}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			this.previous.emitBytecode(method);
			method.node.visitInsn(DUP2);
			method.node.visitInsn(DMUL);
		}
	}

	public static class SqrtIR implements IntermediateRepresentation {

		public static final SqrtIR INSTANCE = new SqrtIR();

		@Override
		public void emitBytecode(MethodCompileContext method) {
			method.node.visitMethodInsn(INVOKESTATIC, "java/lang/Math", "sqrt", "(D)D", false);
		}
	}

	public static class ReciprocalIR implements IntermediateRepresentation {

		public final IntermediateRepresentation first;

		public ReciprocalIR(IntermediateRepresentation first) {
			this.first = first;
		}

		@Override
		public void emitInitialLoadInstructions(MethodCompileContext context) {
			context.node.visitLdcInsn(1.0D);
			context.node.visitVarInsn(DLOAD, context.findParameter("operand").index);
		}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			this.first.emitBytecode(method);
			method.node.visitInsn(DDIV);
		}
	}

	public static class ExtraMultiplyIR implements IntermediateRepresentation {


		public final IntermediateRepresentation last;

		public ExtraMultiplyIR(IntermediateRepresentation last) {
			this.last = last;
		}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			method.node.visitInsn(DUP2);
			this.last.emitBytecode(method);
			method.node.visitInsn(DMUL);
		}
	}

	public static class ProductIR implements IntermediateRepresentation {

		public final IntermediateRepresentation intPart, fracPart;

		public ProductIR(IntermediateRepresentation intPart, IntermediateRepresentation fracPart) {
			this.intPart = intPart;
			this.fracPart = fracPart;
		}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			this.intPart.emitBytecode(method);
			method.node.visitVarInsn(DLOAD, method.findParameter("operand").index);
			this.fracPart.emitBytecode(method);
			method.node.visitInsn(DMUL);
		}

		@Override
		public IntermediateRepresentation compose(IntermediateRepresentation before) {
			throw new UnsupportedOperationException();
		}
	}

	public static class ZeroIR implements IntermediateRepresentation {

		public static final ZeroIR INSTANCE = new ZeroIR();

		@Override
		public void emitBytecode(MethodCompileContext method) {
			method.node.visitMethodInsn(INVOKESTATIC, Type.getInternalName(SpecialCases.class), "zero", "(D)D", false);
		}
	}

	public static class IdentityIR implements IntermediateRepresentation {

		public static final IdentityIR INSTANCE = new IdentityIR();

		@Override
		public void emitBytecode(MethodCompileContext method) {
			//no-op.
		}

		@Override
		public IntermediateRepresentation andThen(IntermediateRepresentation after) {
			return after;
		}

		@Override
		public IntermediateRepresentation compose(IntermediateRepresentation before) {
			return before;
		}
	}

	public static class InfinityIR implements IntermediateRepresentation {

		public static final InfinityIR INSTANCE = new InfinityIR();

		@Override
		public void emitBytecode(MethodCompileContext method) {
			method.node.visitMethodInsn(INVOKESTATIC, Type.getInternalName(SpecialCases.class), "inf", "(D)D", false);
		}
	}

	public static class NaNIR implements IntermediateRepresentation {

		public static final NaNIR INSTANCE = new NaNIR();

		@Override
		public void emitInitialLoadInstructions(MethodCompileContext context) {}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			method.node.visitLdcInsn(Double.NaN);
		}
	}

	public static class DefaultIR implements IntermediateRepresentation {

		public final double power;

		public DefaultIR(double power) {
			this.power = power;
		}

		@Override
		public void emitBytecode(MethodCompileContext method) {
			method.node.visitLdcInsn(this.power);
			method.node.visitMethodInsn(INVOKESTATIC, "java/lang/Math", "pow", "(DD)D", false);
		}
	}

	public static class SpecialCases {

		@SuppressWarnings("unused")
		public static double zero(double operand) {
			return Double.isFinite(operand) ? 1.0D : Double.NaN;
		}

		@SuppressWarnings("unused")
		public static double inf(double operand) {
			operand = Math.abs(operand);
			if (operand > 1.0D) return Double.POSITIVE_INFINITY;
			if (operand < 1.0D) return 0.0D;
			return Double.NaN; //pow(1.0, infinity) and pow(NaN, infinity) are both NaN.
		}
	}
}