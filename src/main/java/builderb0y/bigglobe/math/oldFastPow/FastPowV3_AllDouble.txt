package builderb0y.bigglobe.math;

import java.io.OutputStreamWriter;
import java.io.PrintWriter;
import java.lang.invoke.*;
import java.nio.charset.StandardCharsets;
import java.util.function.*;

import it.unimi.dsi.fastutil.doubles.Double2ObjectMap;
import it.unimi.dsi.fastutil.doubles.Double2ObjectOpenHashMap;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnNode;
import org.objectweb.asm.util.Textifier;
import org.objectweb.asm.util.TraceClassVisitor;

import builderb0y.autocodec.util.AutoCodecUtil;
import builderb0y.scripting.bytecode.*;
import builderb0y.scripting.bytecode.tree.InsnTree;
import builderb0y.scripting.bytecode.tree.conditions.CompareConditionTree;
import builderb0y.scripting.bytecode.tree.flow.IfElseInsnTree;
import builderb0y.scripting.bytecode.tree.flow.IfInsnTree;
import builderb0y.scripting.bytecode.tree.flow.SequenceInsnTree;
import builderb0y.scripting.bytecode.tree.instructions.*;
import builderb0y.scripting.bytecode.tree.instructions.unary.CastInsnTree;

import static org.objectweb.asm.Opcodes.*;

/**
{@link Math#pow(double, double)} is slow.
granted, it's *roughly* O(1), but some specific powers can be done MUCH faster.
for example, x * x * x is faster than pow(x, 3.0).
pow(x, 2.0) is actually the same speed as x * x due to that power being special-cased.
x * x * x * x is faster than pow(x, 4.0), but pow2(pow2(x)) is even faster than x * x * x * x.
binary arithmetic can be used to reduce any integer power into a few multiply and square operations.

fractional exponents are a bit harder, but they're still possible too.
assuming your hardware supports it, {@link Math#sqrt(double)} is faster than pow(x, 0.5).
likewise, sqrt(sqrt(x)) is faster than pow(x, 0.25).

combining the two are also possible, because exponents can be re-arranged:
	pow(x, a) * pow(x, b) = pow(x, a + b)
	pow(pow(x, a), b) = pow(x, a * b)
using these two rules, we can re-write certain fractional exponents too:
	pow(x, 0.25) = sqrt(sqrt(x))
	pow(x, 0.75) = sqrt(sqrt(x) * x)
	pow(x, 1.25) = sqrt(sqrt(x)) * x
	pow(x, 1.5)  = sqrt(x) * x.
	pow(x, 1.75) = sqrt(sqrt(x) * x) * x
any binary fraction (and therefore all floating point values)
can be reduced to some number of sqrt and multiply operations.
however, doing so for powers like 0.3 would result in a *lot* of {@link Math#sqrt(double)} operations.
{@link Math#sqrt(double)} is fast on most modern hardware, but it still adds up.
this class therefore enforces a limit on the maximum number of
operations before falling back on {@link Math#pow(double, double)}.

an alternate representation of the above powers is:
	pow(x, 0.25) = sqrt(sqrt(x))
	pow(x, 0.75) = sqrt(sqrt(x)) * sqrt(x)
	pow(x, 1.25) = sqrt(sqrt(x)) * x
	pow(x, 1.5)  = sqrt(x) * x
	pow(x, 1.75) = sqrt(sqrt(x)) * sqrt(x) * x
this alternate representation was chosen for the actual implementation,
because it is less prone to intermediate underflow issues.
also, while some of the above representations contain duplicate terms,
rest assured that such terms will only be computed once at runtime.

note: computing the power differently than {@link Math#pow(double, double)} does implies
that the results obtained may be different from what {@link Math#pow(double, double)}
would give you. in most cases, results are only off by a few ulps max,
but at the time of writing this, certain special cases are not handled correctly yet.
for example: pow(-infinity, -0.5) would return 0.0D, but the equivalent PowOperator
would return NaN. this is because x ^ -0.5 = 1.0 / sqrt(x), and sqrt(-infinity) is NaN.
such special cases should not be relied on, and this bug may be fixed in the future.
in general, PowOperator's are only intended to handle finite inputs {@link Double#isFinite(double)},
even if the operator itself can raise its input to a non-finite power.

note: the act of creating these operators in the first place is also slow.
much slower than {@link Math#pow(double, double)} in almost all cases.
this class should therefore only be used if you intend
to raise a LOT of numbers to one very specific (usually constant) power.
if the power is not constant, then {@link Math#pow(double, double)} should be used instead.
*/
public class FastPow {

	public static final int MAX_INTEGER_POWER = 256; //why would you ever need a power bigger than this?

	/**
	an operator which raises its argument to a specific power.
	overloads are available to operate on ints, longs, floats, and doubles.

	operators are created by {@link #getOperator(double)},
	and the power is configurable there. additionally, the power an
	operator was created with can be queried via {@link #getPower()}.

	operators generated by {@link #getOperator(double)} will be generated at runtime,
	and given their own bytecode to compute the argument raised
	to the associated power in as few instructions as possible.
	this ensures that invoking {@link #applyAsDouble(double)} for
	example has an overhead of at most 1 megamorphic call site,
	plus the operations involved in actually computing the requested value.
	*/
	public static abstract class FastPowOperator implements IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator {

		@Override
		public abstract int applyAsInt(int x);

		@Override
		public abstract long applyAsLong(long x);

		public abstract float applyAsFloat(float x);

		@Override
		public abstract double applyAsDouble(double x);

		public abstract double getPower();
	}

	public static record CacheEntry(
		MethodHandles.Lookup lookup,
		FastPowOperator operator,
		CallSite intCallSite,
		CallSite longCallSite,
		CallSite floatCallSite,
		CallSite doubleCallSite
	) {

		public Class<? extends FastPowOperator> operatorClass() {
			return this.lookup.lookupClass().asSubclass(FastPowOperator.class);
		}

		public MethodHandle    intHandle() { return this.   intCallSite.getTarget(); }
		public MethodHandle   longHandle() { return this.  longCallSite.getTarget(); }
		public MethodHandle  floatHandle() { return this. floatCallSite.getTarget(); }
		public MethodHandle doubleHandle() { return this.doubleCallSite.getTarget(); }
	}

	public static final Double2ObjectMap<CacheEntry> CACHE = new Double2ObjectOpenHashMap<>(16);

	public static FastPowOperator getOperator(double power) {
		return getCacheEntry(power).operator;
	}

	public static final MethodType
		INT_METHOD_TYPE    = MethodType.methodType(   int.class,    int.class),
		LONG_METHOD_TYPE   = MethodType.methodType(  long.class,   long.class),
		FLOAT_METHOD_TYPE  = MethodType.methodType( float.class,  float.class),
		DOUBLE_METHOD_TYPE = MethodType.methodType(double.class, double.class);

	/**
	returns a CallSite whose {@link CallSite#getTarget()} performs the same
	operation as a {@link FastPowOperator} created with the same exponent.
	this method is intended to be called by an INVOKEDYNAMIC instruction,
	typically generated by scripting languages which output java bytecode.

	first 3 parameters are provided automatically by the VM, but the first 2 are ignored.
	*/
	public static CallSite getCallSite(MethodHandles.Lookup lookup, String name, MethodType methodType, double power) {
		if (methodType ==    INT_METHOD_TYPE) return getCacheEntry(power).   intCallSite;
		if (methodType ==   LONG_METHOD_TYPE) return getCacheEntry(power).  longCallSite;
		if (methodType ==  FLOAT_METHOD_TYPE) return getCacheEntry(power). floatCallSite;
		if (methodType == DOUBLE_METHOD_TYPE) return getCacheEntry(power).doubleCallSite;
		throw new WrongMethodTypeException(methodType.toString());
	}

	public static CacheEntry getCacheEntry(double power) {
		synchronized (CACHE) {
			CacheEntry entry = CACHE.get(power);
			if (entry == null) {
				entry = createCacheEntry(power);
				CACHE.put(power, entry);
			}
			return entry;
		}
	}

	//////////////////////////////// default handling ////////////////////////////////

	public static int pow(int a, int b) {
		if (b > 0) {
			if (b > MAX_INTEGER_POWER) {
				throw new ArithmeticException("Integer power too large: " + b);
			}
			int result = a;
			int bit = Integer.highestOneBit(b);
			while ((bit >>>= 1) != 0) {
				result *= result;
				if ((b & bit) != 0) {
					result *= a;
				}
			}
			return result;
		}
		else if (b < 0) {
			return (b & 1) == 0 ? negativeEven(a) : negativeOdd(a);
		}
		else {
			return 1;
		}
	}

	public static long pow(long a, int b) {
		if (b > 0L) {
			if (b > MAX_INTEGER_POWER) {
				throw new ArithmeticException("Integer power too large: " + b);
			}
			long result = a;
			int bit = Integer.highestOneBit(b);
			while ((bit >>>= 1) != 0) {
				result *= result;
				if ((b & bit) != 0) {
					result *= a;
				}
			}
			return result;
		}
		else if (b < 0L) {
			return (b & 1) == 0 ? negativeEven(a) : negativeOdd(a);
		}
		else {
			return 1;
		}
	}

	public static float pow(float a, int b) {
		if (b == 0) return 1.0F;
		boolean negative = b < 0;
		if (negative) b = -b;
		float result = a;
		int bit = Integer.highestOneBit(b);
		while ((bit >>>= 1) != 0) {
			result *= result;
			if ((b & bit) != 0) {
				result *= a;
			}
		}
		if (negative) result = 1.0F / result;
		return result;
	}

	public static double pow(double a, int b) {
		if (b == 0) return 1.0D;
		boolean negative = b < 0;
		if (negative) b = -b;
		double result = a;
		int bit = Integer.highestOneBit(b);
		while ((bit >>>= 1) != 0) {
			result *= result;
			if ((b & bit) != 0) {
				result *= a;
			}
		}
		if (negative) result = 1.0D / result;
		return result;
	}

	public static float pow(float a, float b) {
		return (float)(Math.pow((double)(a), (double)(b)));
	}

	//////////////////////////////// special cases ////////////////////////////////

	public static int negativeEven(int operand) {
		if (operand ==  1) return 1;
		if (operand ==  0) throw new ArithmeticException("divide by 0");
		if (operand == -1) return 1;
		return 0;
	}

	public static long negativeEven(long operand) {
		if (operand ==  1L) return 1L;
		if (operand ==  0L) throw new ArithmeticException("divide by 0");
		if (operand == -1L) return 1L;
		return 0L;
	}

	public static int negativeOdd(int operand) {
		if (operand ==  1) return 1;
		if (operand ==  0) throw new ArithmeticException("divide by 0");
		if (operand == -1) return -1;
		return 0;
	}

	public static long negativeOdd(long operand) {
		if (operand ==  1L) return 1L;
		if (operand ==  0L) throw new ArithmeticException("divide by 0");
		if (operand == -1L) return -1L;
		return 0L;
	}

	//////////////////////////////// bytecode generation ////////////////////////////////

	public static int counter;
	public static final boolean DEBUG = false;

	public static final MethodInfo ARITHMETIC_EXCEPTION = new MethodInfo(
		ACC_PUBLIC,
		"java/lang/ArithmeticException",
		"<init>",
		"(Ljava/lang/String;)V",
		false
	);

	public static CacheEntry createCacheEntry(double power) {
		assert Thread.holdsLock(CACHE);
		ClassCompileContext clazz = new ClassCompileContext(
			ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,
			ClassType.CLASS,
			Type.getInternalName(FastPowOperator.class) + '$' + counter++,
			ClassInfo.of(FastPowOperator.class),
			ClassInfo.ARRAY_FACTORY.empty()
		);
		clazz.addNoArgConstructor(ACC_PUBLIC);

		if (power == 0.0D) {
			emitZero(clazz);
		}
		else if (power == Double.POSITIVE_INFINITY) {
			emitInfinity(clazz);
		}
		else if (power == Double.NEGATIVE_INFINITY) {
			emitNegativeInfinity(clazz);
		}
		else if (Double.isNaN(power)) {
			emitNaN(clazz);
		}
		else {
			emitNormal(clazz, power);
		}

		MethodCompileContext getPower = clazz.newMethod(ACC_PUBLIC, "getPower", "()D");
		getPower.scopes.pushScope();
		getPower.addThis();
		new ReturnInsnTree(new ConstantInsnTree(power)).emitBytecode(getPower);
		getPower.scopes.popScope();

		clazz.addToString("FastPowOperator(" + power + ')');

		return defineClass(clazz, power);
	}

	public static void emitNaN(ClassCompileContext clazz) {
		emitMethods(
			clazz,
			(MethodCompileContext method, VarInfo operand) -> {
				fail("Can't raise " + operand.type.getClassName() + " to NaN power").emitBytecode(method);
			},
			(MethodCompileContext method, VarInfo operand) -> {
				new ReturnInsnTree(new ConstantInsnTree(Float.NaN, operand.type)).emitBytecode(method);
			}
		);
	}

	public static void emitZero(ClassCompileContext clazz) {
		emitMethods(clazz, (MethodCompileContext method, VarInfo operand) -> {
			new ReturnInsnTree(new ConstantInsnTree(1, operand.type)).emitBytecode(method);
		});
	}

	public static void emitInfinity(ClassCompileContext clazz) {
		emitMethods(
			clazz,
			(MethodCompileContext method) -> {
				if (!method.info.isStatic()) method.addThis();
				Type numberType = method.info.desc.getReturnType();
				VarInfo operand = method.newParameter("operand", numberType);
				new IfElseInsnTree(
					CompareConditionTree.equal(new LoadInsnTree(operand), new ConstantInsnTree(1, numberType)),
					new ReturnInsnTree(new ConstantInsnTree(1, numberType)),
					new IfElseInsnTree(
						CompareConditionTree.equal(new LoadInsnTree(operand), new ConstantInsnTree(0, numberType)),
						new ReturnInsnTree(new ConstantInsnTree(0, numberType)),
						new IfElseInsnTree(
							CompareConditionTree.equal(new LoadInsnTree(operand), new ConstantInsnTree(-1, numberType)),
							new ReturnInsnTree(new ConstantInsnTree(1, numberType)),
							fail("Can't raise " + numberType.getClassName() + " to infinite power"),
							Type.VOID_TYPE
						),
						Type.VOID_TYPE
					),
					Type.VOID_TYPE
				)
				.emitBytecode(method);
			},
			(MethodCompileContext method) -> {
				if (!method.info.isStatic()) method.addThis();
				Type numberType = method.info.desc.getReturnType();
				VarInfo operand = method.newParameter("operand", numberType);
				new ReturnInsnTree(
					SequenceInsnTree.create(
						absFD(operand),
						switchOne(
							operand,
							new ConstantInsnTree(0.0F, numberType),
							new ConstantInsnTree(Float.POSITIVE_INFINITY, numberType)
						)
					)
				)
				.emitBytecode(method);
			}
		);
	}

	public static void emitNegativeInfinity(ClassCompileContext clazz) {
		emitMethods(
			clazz,
			(MethodCompileContext method, VarInfo operand) -> {
				new ReturnInsnTree(negativeInt(operand, true)).emitBytecode(method);
			},
			(MethodCompileContext method, VarInfo operand) -> {
				new ReturnInsnTree(
					SequenceInsnTree.create(
						absFD(operand),
						switchOne(
							operand,
							new ConstantInsnTree(Float.POSITIVE_INFINITY, operand.type),
							new ConstantInsnTree(0.0F, operand.type)
						)
					)
				)
				.emitBytecode(method);
			}
		);
	}

	@SuppressWarnings("UseOfRemainderOperator") //need to check if a double is even or odd.
	public static void emitNormal(ClassCompileContext clazz, double power) {
		boolean negative = power < 0.0D;
		double absPower = Math.abs(power);
		int intPart = (int)(absPower);
		double fracPart = absPower - intPart;
		if (intPart > MAX_INTEGER_POWER) {
			emitMethods(
				clazz,
				(MethodCompileContext method, VarInfo operand) -> {
					double floorPower = Math.floor(absPower);
					if (floorPower != absPower) {
						fail("Can't raise " + operand.type.getClassName() + " to non-integer power: " + power).emitBytecode(method);
					}
					else if (negative) {
						new ReturnInsnTree(negativeInt(operand, (floorPower % 2.0D) == 0.0D)).emitBytecode(method);
					}
					else {
						fail("Integer power too large: " + power).emitBytecode(method);
					}
				},
				(MethodCompileContext method, VarInfo operand) -> {
					new ReturnInsnTree(fallback(operand, power)).emitBytecode(method);
				}
			);
		}
		else if (fracPart == 0.0D) {
			if (negative) {
				emitMethods(
					clazz,
					(MethodCompileContext method, VarInfo operand) -> {
						negativeInt(operand, (intPart & 1) == 0).emitBytecode(method);
						method.node.visitInsn(operand.type.getOpcode(IRETURN));
					},
					(MethodCompileContext method, VarInfo operand) -> {
						new ConstantInsnTree(1.0F, operand.type).emitBytecode(method);
						emitIntPart(method, intPart, Integer.MAX_VALUE);
						method.node.visitInsn(operand.type.getOpcode(IDIV));
						method.node.visitInsn(operand.type.getOpcode(IRETURN));
					}
				);
			}
			else {
				emitMethods(clazz, (MethodCompileContext method, VarInfo operand) -> {
					emitIntPart(method, intPart, Integer.MAX_VALUE);
					method.node.visitInsn(operand.type.getOpcode(IRETURN));
				});
			}
		}
		else {
			emitMethods(
				clazz,
				(MethodCompileContext method, VarInfo operand) -> {
					fail("Can't raise " + operand.type.getClassName() + " to non-integer power: " + power).emitBytecode(method);
				},
				(MethodCompileContext method, VarInfo operand) -> {
					AbstractInsnNode first = method.node.instructions.getFirst();
					if (absPower % 2.0D != 1.0D) {
						new IfInsnTree(
							CompareConditionTree.equal(
								new LoadInsnTree(operand),
								new ConstantInsnTree(Float.NEGATIVE_INFINITY, operand.type)
							),
							new ReturnInsnTree(new ConstantInsnTree(Float.POSITIVE_INFINITY, operand.type))
						)
						.emitBytecode(method);
					}
					boolean success;
					if (intPart == 0) {
						success = emitFracPart(method, fracPart, 4, 2);
					}
					else {
						//noinspection AssignmentUsedAsCondition
						if (success = emitIntPart(method, intPart, 8) && emitFracPart(method, fracPart, 4, 2)) {
							method.node.instructions.add(new InsnNode(operand.type.getOpcode(IMUL)));
						}
					}
					if (success) {
						if (negative) {
							method.node.instructions.insert(first, new InsnNode(operand.type.getSize() == 2 ? DCONST_1 : FCONST_1));
							method.node.instructions.add(new InsnNode(operand.type.getOpcode(IDIV)));
						}
					}
					else {
						for (AbstractInsnNode remove; (remove = first.getNext()) != null;) {
							method.node.instructions.remove(remove);
						}
						//fall back on Math.pow().
						fallback(operand, power).emitBytecode(method);
					}
					method.node.visitInsn(operand.type.getOpcode(IRETURN));
				}
			);
		}
	}

	/** returns an InsnTree which represents the operation "x = Math.abs(x)". */
	public static InsnTree absFD(VarInfo operand) {
		return new StoreInsnTree(
			operand,
			new InvokeStaticInsnTree(
				new MethodInfo(
					ACC_PUBLIC | ACC_STATIC,
					Type.getObjectType("java/lang/Math"),
					"abs",
					Type.getMethodType(operand.type, operand.type),
					false
				),
				new LoadInsnTree(operand)
			)
		);
	}

	/**
	returns an InsnTree which represents the following ternary chain:
		x < 1 ? zero : (x > 1 ? other : 1)
	*/
	public static InsnTree switchOne(VarInfo variable, InsnTree zero, InsnTree other) {
		return new IfElseInsnTree(
			CompareConditionTree.lessThan(
				new LoadInsnTree(variable),
				new ConstantInsnTree(1, variable.type)
			),
			zero,
			new IfElseInsnTree(
				CompareConditionTree.greaterThan(
					new LoadInsnTree(variable),
					new ConstantInsnTree(1, variable.type)
				),
				other,
				new ConstantInsnTree(Float.NaN, variable.type),
				variable.type
			),
			variable.type
		);
	}

	/**
	returns an InsnTree which performs the same operations as
	{@link #negativeEven(int)} or {@link #negativeOdd(int)},
	depending on whether or not the "even" parameter is set to true.
	*/
	public static InsnTree negativeInt(VarInfo operand, boolean even) {
		return new IfElseInsnTree(
			CompareConditionTree.equal(new LoadInsnTree(operand), new ConstantInsnTree(1, operand.type)),
			new ReturnInsnTree(new ConstantInsnTree(1, operand.type)),
			new IfElseInsnTree(
				CompareConditionTree.equal(new LoadInsnTree(operand), new ConstantInsnTree(0, operand.type)),
				fail("divide by 0"),
				new IfElseInsnTree(
					CompareConditionTree.equal(new LoadInsnTree(operand), new ConstantInsnTree(-1, operand.type)),
					new ReturnInsnTree(new ConstantInsnTree(even ? 1 : -1, operand.type)),
					new ReturnInsnTree(new ConstantInsnTree(0, operand.type)),
					Type.VOID_TYPE
				),
				Type.VOID_TYPE
			),
			Type.VOID_TYPE
		);
	}

	/** returns an InsnTree which represents Math.pow(operand, power). */
	public static InsnTree fallback(VarInfo operand, double power) {
		return CastInsnTree.create(
			new InvokeStaticInsnTree(
				new MethodInfo(ACC_PUBLIC, "java/lang/Math", "pow", "(DD)D", false),
				CastInsnTree.create(new LoadInsnTree(operand), Type.DOUBLE_TYPE),
				new ConstantInsnTree(power)
			),
			operand.type
		);
	}

	/** returns an InsnTree which represents new ArithmeticException(reason). */
	public static InsnTree fail(String reason) {
		return new ThrowInsnTree(new NewInsnTree(ARITHMETIC_EXCEPTION, new ConstantInsnTree(reason)));
	}

	public static Consumer<MethodCompileContext> addOperand(BiConsumer<MethodCompileContext, VarInfo> action) {
		return (MethodCompileContext method) -> {
			if (!method.info.isStatic()) method.addThis();
			VarInfo operand = method.newParameter("operand", method.info.desc.getReturnType());
			action.accept(method, operand);
		};
	}

	public static void emitMethods(ClassCompileContext clazz, BiConsumer<MethodCompileContext, VarInfo> action) {
		emitMethods(clazz, addOperand(action));
	}

	public static void emitMethods(ClassCompileContext clazz, BiConsumer<MethodCompileContext, VarInfo> intConsumer, BiConsumer<MethodCompileContext, VarInfo> floatConsumer) {
		emitMethods(clazz, addOperand(intConsumer), addOperand(floatConsumer));
	}

	public static void emitMethods(ClassCompileContext clazz, Consumer<MethodCompileContext> consumer) {
		emitMethods(clazz, consumer, consumer);
	}

	public static void emitMethods(ClassCompileContext clazz, Consumer<MethodCompileContext> intConsumer, Consumer<MethodCompileContext> floatConsumer) {
		clazz.newMethod(ACC_PUBLIC, "applyAsInt",       "(I)I").scopes.withScope(  intConsumer);
		clazz.newMethod(ACC_PUBLIC, "applyAsLong",      "(J)J").scopes.withScope(  intConsumer);
		clazz.newMethod(ACC_PUBLIC, "applyAsFloat",     "(F)F").scopes.withScope(floatConsumer);
		clazz.newMethod(ACC_PUBLIC, "applyAsDouble",    "(D)D").scopes.withScope(floatConsumer);
		clazz.newMethod(ACC_PUBLIC | ACC_STATIC, "pow", "(I)I").scopes.withScope(  intConsumer);
		clazz.newMethod(ACC_PUBLIC | ACC_STATIC, "pow", "(J)J").scopes.withScope(  intConsumer);
		clazz.newMethod(ACC_PUBLIC | ACC_STATIC, "pow", "(F)F").scopes.withScope(floatConsumer);
		clazz.newMethod(ACC_PUBLIC | ACC_STATIC, "pow", "(D)D").scopes.withScope(floatConsumer);
	}

	public static CacheEntry defineClass(ClassCompileContext clazz, double power) {
		if (DEBUG) {
			System.out.println("FastPowOperator created with power " + power + ':');
			clazz.node.accept(new TraceClassVisitor(null, new Textifier(), new PrintWriter(new OutputStreamWriter(System.out, StandardCharsets.UTF_8))));
		}
		try {
			MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(clazz.toByteArray(), true);
			Class<?> operatorClass = lookup.lookupClass();
			return new CacheEntry(
				lookup,
				(FastPowOperator)(lookup.findConstructor(operatorClass, MethodType.methodType(void.class)).invoke()),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(int.class, int.class))),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(long.class, long.class))),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(float.class, float.class))),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(double.class, double.class)))
			);
		}
		catch (Throwable throwable) {
			throw AutoCodecUtil.rethrow(throwable);
		}
	}

	public static boolean emitIntPart(final MethodCompileContext method, final int power, int limit) {
		assert power >= 0 : power;
		VarInfo operand = method.findParameter("operand");
		method.node.visitVarInsn(operand.type.getOpcode(ILOAD), operand.index);
		int bit = Integer.highestOneBit(power);
		//read bits from most significant to least significant.
		//bit will eventually underflow to 0.
		while ((bit >>>= 1) != 0) {
			if (--limit < 0) return false;
			method.node.visitInsn(operand.type.getSize() == 2 ? DUP2 : DUP);
			method.node.visitInsn(operand.type.getOpcode(IMUL));
			if ((power & bit) != 0) {
				if (--limit < 0) return false;
				method.node.visitVarInsn(operand.type.getOpcode(ILOAD), operand.index);
				method.node.visitInsn(operand.type.getOpcode(IMUL));
			}
		}
		return true;
	}

	public static boolean emitFracPart(final MethodCompileContext method, final double power, int mulLimit, int sqrtLimit) {
		assert power > 0.0D && power < 1.0D : power;
		VarInfo operand = method.findParameter("operand");
		final long bits = (Double.doubleToRawLongBits(power + 1.0D) & 0x000FFFFFFFFFFFFFL) << 12;
		//adding 1.0 can cause precision loss.
		//if this precision loss is enough to completely zero out the least significant bits,
		//then we would've needed enough sqrts to fail sqrtLimit anyway.
		if (bits == 0L) return false;
		method.node.visitVarInsn(operand.type.getOpcode(ILOAD), operand.index);
		if (operand.type.getSort() == Type.FLOAT) method.node.visitInsn(F2D);
		if (--sqrtLimit < 0) return false;
		method.node.visitMethodInsn(INVOKESTATIC, "java/lang/Math", "sqrt", "(D)D", false);
		for (long shiftedBits = bits; shiftedBits != Long.MIN_VALUE; shiftedBits <<= 1) {
			if ((shiftedBits & Long.MIN_VALUE) != 0) {
				method.node.visitInsn(DUP2);
			}
			if (--sqrtLimit < 0) return false;
			method.node.visitMethodInsn(INVOKESTATIC, "java/lang/Math", "sqrt", "(D)D", false);
		}
		for (int mul = Long.bitCount(bits); --mul > 0;) {
			if (--mulLimit < 0) return false;
			method.node.visitInsn(DMUL);
		}
		if (operand.type.getSort() == Type.FLOAT) method.node.visitInsn(D2F);
		return true;
	}
}