package builderb0y.bigglobe.math;

import java.lang.invoke.*;
import java.util.function.Consumer;
import java.util.function.DoubleUnaryOperator;
import java.util.function.IntUnaryOperator;
import java.util.function.LongUnaryOperator;

import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import org.objectweb.asm.Type;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.InsnNode;

import builderb0y.autocodec.util.AutoCodecUtil;
import builderb0y.scripting.bytecode.*;
import builderb0y.scripting.bytecode.tree.InsnTree;
import builderb0y.scripting.util.TypeInfos;

import static builderb0y.scripting.bytecode.InsnTrees.*;

/**
{@link Math#pow(double, double)} is slow.
granted, it's *roughly* O(1), but some specific powers can be done MUCH faster.
for example, x * x * x is faster than pow(x, 3.0).
pow(x, 2.0) is actually the same speed as x * x due to that power being special-cased.
x * x * x * x is faster than pow(x, 4.0), but square(square(x)) is even faster than x * x * x * x.
	pow(x, 5) = square(square(x)) * x
	pow(x, 6) = square(square(x) * x)
	pow(x, 7) = square(square(x) * x) * x
	pow(x, 8) = square(square(square(x)))
and so on. binary arithmetic can be used to reduce any
integer power into a few multiply and square operations.

fractional powers can be decomposed in a similar way,
and I have done this before, but unit testing has shown
that matching all the edge cases {@link Math#pow(double, double)}
handles is a massive pain in the ass,
particularly for numbers like -infinity and -0.0.
did you know Math.sqrt(-0.0) = -0.0, but Math.pow(-0.0, 0.5) = +0.0?

anyway, I have been trying to match all these special cases for multiple
days now, and I am tired of working on that. as such, the current version
of this class will only handle raising numbers to integer powers.
*/
public class FastPow {

	/**
	an operator which raises its argument to a specific power.
	overloads are available to operate on ints, longs, floats, and doubles.

	operators are created by {@link #getOperator(int)},
	and the power is configurable there. additionally, the power an
	operator was created with can be queried via {@link #getPower()}.

	operators generated by {@link #getOperator(int)} will be generated at runtime,
	and given their own bytecode to compute the argument raised
	to the associated power in as few instructions as possible.
	this ensures that invoking {@link #applyAsDouble(double)} for
	example has an overhead of at most 1 megamorphic call site,
	plus the operations involved in actually computing the requested value.
	*/
	public static abstract class FastPowOperator implements IntUnaryOperator, LongUnaryOperator, DoubleUnaryOperator {

		@Override
		public abstract int applyAsInt(int x);

		@Override
		public abstract long applyAsLong(long x);

		public abstract float applyAsFloat(float x);

		@Override
		public abstract double applyAsDouble(double x);

		public abstract int getPower();
	}

	public static record CacheEntry(
		MethodHandles.Lookup lookup,
		FastPowOperator operator,
		CallSite intCallSite,
		CallSite longCallSite,
		CallSite floatCallSite,
		CallSite doubleCallSite
	) {

		public Class<? extends FastPowOperator> operatorClass() {
			return this.lookup.lookupClass().asSubclass(FastPowOperator.class);
		}

		public int power() { return this.operator.getPower(); }

		public MethodHandle    intHandle() { return this.   intCallSite.getTarget(); }
		public MethodHandle   longHandle() { return this.  longCallSite.getTarget(); }
		public MethodHandle  floatHandle() { return this. floatCallSite.getTarget(); }
		public MethodHandle doubleHandle() { return this.doubleCallSite.getTarget(); }
	}

	public static final Int2ObjectMap<CacheEntry> CACHE = new Int2ObjectOpenHashMap<>(4);

	/** returns a {@link FastPowOperator} which raises numbers to the provided power. */
	public static FastPowOperator getOperator(int power) {
		return getCacheEntry(power).operator;
	}

	public static final MethodType
		INT_METHOD_TYPE    = MethodType.methodType(   int.class,    int.class),
		LONG_METHOD_TYPE   = MethodType.methodType(  long.class,   long.class),
		FLOAT_METHOD_TYPE  = MethodType.methodType( float.class,  float.class),
		DOUBLE_METHOD_TYPE = MethodType.methodType(double.class, double.class);
	public static final MethodInfo
		MATH_POW = MethodInfo.getMethod(Math.class, "pow");

	/**
	returns a CallSite whose {@link CallSite#getTarget()} performs the same
	operation as a {@link FastPowOperator} created with the same exponent.
	this method is intended to be called by an INVOKEDYNAMIC instruction,
	typically generated by scripting languages which output java bytecode.

	first 3 parameters are provided automatically by the VM, but the first 2 are ignored.
	*/
	public static CallSite getCallSite(MethodHandles.Lookup lookup, String name, MethodType methodType, int power) {
		if (methodType ==    INT_METHOD_TYPE) return getCacheEntry(power).   intCallSite;
		if (methodType ==   LONG_METHOD_TYPE) return getCacheEntry(power).  longCallSite;
		if (methodType ==  FLOAT_METHOD_TYPE) return getCacheEntry(power). floatCallSite;
		if (methodType == DOUBLE_METHOD_TYPE) return getCacheEntry(power).doubleCallSite;
		throw new WrongMethodTypeException(methodType.toString());
	}

	public static CacheEntry getCacheEntry(int power) {
		synchronized (CACHE) {
			CacheEntry entry = CACHE.get(power);
			if (entry == null) {
				entry = createCacheEntry(power);
				CACHE.put(power, entry);
			}
			return entry;
		}
	}

	//////////////////////////////// default handling ////////////////////////////////

	public static int pow(int a, int b) {
		if (b > 0) {
			int result = a;
			int bit = Integer.highestOneBit(b);
			while ((bit >>>= 1) != 0) {
				result *= result;
				if ((b & bit) != 0) {
					result *= a;
				}
			}
			return result;
		}
		else if (b < 0) {
			return (b & 1) == 0 ? negativeEven(a) : negativeOdd(a);
		}
		else {
			return 1;
		}
	}

	public static long pow(long a, int b) {
		if (b > 0L) {
			long result = a;
			int bit = Integer.highestOneBit(b);
			while ((bit >>>= 1) != 0) {
				result *= result;
				if ((b & bit) != 0) {
					result *= a;
				}
			}
			return result;
		}
		else if (b < 0L) {
			return (b & 1) == 0 ? negativeEven(a) : negativeOdd(a);
		}
		else {
			return 1;
		}
	}

	public static float pow(float a, int b) {
		if (b == 0) return 1.0F;
		boolean negative = b < 0;
		if (negative) b = -b;
		float result = a;
		int bit = Integer.highestOneBit(b);
		while ((bit >>>= 1) != 0) {
			result *= result;
			if ((b & bit) != 0) {
				result *= a;
			}
		}
		if (negative) result = 1.0F / result;
		return result;
	}

	public static double pow(double a, int b) {
		if (b == 0) return 1.0D;
		boolean negative = b < 0;
		if (negative) b = -b;
		double result = a;
		int bit = Integer.highestOneBit(b);
		while ((bit >>>= 1) != 0) {
			result *= result;
			if ((b & bit) != 0) {
				result *= a;
			}
		}
		if (negative) result = 1.0D / result;
		return result;
	}

	public static float pow(float a, float b) {
		return (float)(Math.pow((double)(a), (double)(b)));
	}

	public static float exp(float x) {
		return (float)(Math.exp((double)(x)));
	}

	//////////////////////////////// special cases ////////////////////////////////

	public static int negativeEven(int operand) {
		if (operand ==  1) return 1;
		if (operand ==  0) throw new ArithmeticException("divide by 0");
		if (operand == -1) return 1;
		return 0;
	}

	public static long negativeEven(long operand) {
		if (operand ==  1L) return 1L;
		if (operand ==  0L) throw new ArithmeticException("divide by 0");
		if (operand == -1L) return 1L;
		return 0L;
	}

	public static int negativeOdd(int operand) {
		if (operand ==  1) return 1;
		if (operand ==  0) throw new ArithmeticException("divide by 0");
		if (operand == -1) return -1;
		return 0;
	}

	public static long negativeOdd(long operand) {
		if (operand ==  1L) return 1L;
		if (operand ==  0L) throw new ArithmeticException("divide by 0");
		if (operand == -1L) return -1L;
		return 0L;
	}

	//////////////////////////////// bytecode generation ////////////////////////////////

	//only used when synchronized on CACHE, so it's safe to have this be non-atomic.
	public static int counter;

	public static CacheEntry createCacheEntry(int power) {
		assert Thread.holdsLock(CACHE);
		ClassCompileContext clazz = new ClassCompileContext(
			ACC_PUBLIC | ACC_FINAL | ACC_SYNTHETIC,
			ClassType.CLASS,
			Type.getInternalName(FastPowOperator.class) + '$' + counter++,
			TypeInfo.of(FastPowOperator.class),
			TypeInfo.ARRAY_FACTORY.empty()
		);
		clazz.addNoArgConstructor(ACC_PUBLIC);

		if (power > 0) {
			emitPositive(clazz, power);
		}
		else if (power < 0) {
			emitNegative(clazz, power);
		}
		else {
			emitZero(clazz);
		}

		MethodCompileContext getPower = clazz.newMethod(ACC_PUBLIC, "getPower", TypeInfos.INT);
		return_(ldc(power)).emitBytecode(getPower);
		getPower.endCode();

		clazz.addToString("FastPowOperator(" + power + ')');

		return defineClass(clazz);
	}

	public static void emitPositive(ClassCompileContext clazz, int power) {
		emitMethods(
			clazz,
			(MethodCompileContext intMethod, LazyVarInfo operand) -> {
				emitNormalInstructions(intMethod, operand, power, Integer.MAX_VALUE);
				intMethod.node.visitInsn(operand.type.getOpcode(IRETURN));
			},
			(MethodCompileContext floatMethod, LazyVarInfo operand) -> {
				AbstractInsnNode first = floatMethod.node.instructions.getFirst();
				if (!emitNormalInstructions(floatMethod, operand, power, 8)) {
					for (AbstractInsnNode remove; (remove = first.getNext()) != null;) {
						floatMethod.node.instructions.remove(remove);
					}
					fallback(operand, power).emitBytecode(floatMethod);
				}
				floatMethod.node.visitInsn(operand.type.getOpcode(IRETURN));
			}
		);
	}

	public static void emitNegative(ClassCompileContext clazz, int power) {
		emitMethods(
			clazz,
			(MethodCompileContext intMethod, LazyVarInfo operand) -> {
				operand.emitLoad(intMethod);
				intMethod.node.visitMethodInsn(
					INVOKESTATIC,
					Type.getInternalName(FastPow.class),
					(power & 1) != 0 ? "negativeOdd" : "negativeEven",
					operand.type.isDoubleWidth() ? "(J)J" : "(I)I",
					false
				);
				intMethod.node.visitInsn(operand.type.getOpcode(IRETURN));
			},
			(MethodCompileContext floatMethod, LazyVarInfo operand) -> {
				AbstractInsnNode first = floatMethod.node.instructions.getFirst();
				if (emitNormalInstructions(floatMethod, operand, power, 8)) {
					floatMethod.node.instructions.insert(first, new InsnNode(operand.type.isDoubleWidth() ? DCONST_1 : FCONST_1));
					floatMethod.node.instructions.add(new InsnNode(operand.type.getOpcode(IDIV)));
				}
				else {
					for (AbstractInsnNode remove; (remove = first.getNext()) != null;) {
						floatMethod.node.instructions.remove(remove);
					}
					fallback(operand, power).emitBytecode(floatMethod);
				}
				floatMethod.node.visitInsn(operand.type.getOpcode(IRETURN));
			}
		);
	}

	public static void emitZero(ClassCompileContext clazz) {
		emitMethods(clazz, (MethodCompileContext method, LazyVarInfo operand) -> {
			return_(ldc(1, operand.type)).emitBytecode(method);
		});
	}

	public static boolean emitNormalInstructions(MethodCompileContext method, LazyVarInfo operand, int power, int limit) {
		method.node.visitVarInsn(operand.type.getOpcode(ILOAD), method.scopes.getVariableIndex(operand));
		int bit = Integer.highestOneBit(power);
		//read bits from most significant to least significant.
		//bit will eventually underflow to 0.
		while ((bit >>>= 1) != 0) {
			if (--limit < 0) return false;
			method.node.visitInsn(operand.type.isDoubleWidth() ? DUP2 : DUP);
			method.node.visitInsn(operand.type.getOpcode(IMUL));
			if ((power & bit) != 0) {
				if (--limit < 0) return false;
				method.node.visitVarInsn(operand.type.getOpcode(ILOAD), method.scopes.getVariableIndex(operand));
				method.node.visitInsn(operand.type.getOpcode(IMUL));
			}
		}
		return true;
	}

	/** returns an InsnTree which represents Math.pow(operand, power). */
	public static InsnTree fallback(LazyVarInfo operand, int power) {
		return CastingSupport.primitiveCast(
			invokeStatic(
				MATH_POW,
				CastingSupport.primitiveCast(
					load(operand),
					TypeInfos.DOUBLE
				),
				ldc(power, TypeInfos.DOUBLE)
			),
			operand.type
		);
	}

	public static void emitMethods(ClassCompileContext clazz, MethodPopulator populator) {
		emitMethods(clazz, populator, populator);
	}

	public static void emitMethods(ClassCompileContext clazz, MethodPopulator intConsumer, MethodPopulator floatConsumer) {
		emitMethod(clazz, ACC_PUBLIC, "applyAsInt",       TypeInfos.INT,      intConsumer);
		emitMethod(clazz, ACC_PUBLIC, "applyAsLong",      TypeInfos.LONG,     intConsumer);
		emitMethod(clazz, ACC_PUBLIC, "applyAsFloat",     TypeInfos.FLOAT,  floatConsumer);
		emitMethod(clazz, ACC_PUBLIC, "applyAsDouble",    TypeInfos.DOUBLE, floatConsumer);
		emitMethod(clazz, ACC_PUBLIC | ACC_STATIC, "pow", TypeInfos.INT,      intConsumer);
		emitMethod(clazz, ACC_PUBLIC | ACC_STATIC, "pow", TypeInfos.LONG,     intConsumer);
		emitMethod(clazz, ACC_PUBLIC | ACC_STATIC, "pow", TypeInfos.FLOAT,  floatConsumer);
		emitMethod(clazz, ACC_PUBLIC | ACC_STATIC, "pow", TypeInfos.DOUBLE, floatConsumer);
	}

	public static void emitMethod(ClassCompileContext clazz, int flags, String name, TypeInfo type, MethodPopulator populator) {
		LazyVarInfo operand = new LazyVarInfo("operand", type);
		MethodCompileContext method = clazz.newMethod(flags, name, type, operand);
		populator.populate(method, operand);
		method.endCode();
	}

	public static interface MethodPopulator {

		public abstract void populate(MethodCompileContext method, LazyVarInfo operand);
	}

	public static CacheEntry defineClass(ClassCompileContext clazz) {
		try {
			MethodHandles.Lookup lookup = MethodHandles.lookup().defineHiddenClass(clazz.toByteArray(), true);
			Class<?> operatorClass = lookup.lookupClass();
			return new CacheEntry(
				lookup,
				(FastPowOperator)(lookup.findConstructor(operatorClass, MethodType.methodType(void.class)).invoke()),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(int.class, int.class))),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(long.class, long.class))),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(float.class, float.class))),
				new ConstantCallSite(lookup.findStatic(operatorClass, "pow", MethodType.methodType(double.class, double.class)))
			);
		}
		catch (Throwable throwable) {
			throw AutoCodecUtil.rethrow(throwable);
		}
	}
}