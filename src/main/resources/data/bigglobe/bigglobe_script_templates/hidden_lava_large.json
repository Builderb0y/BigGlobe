{
	"script": [
		"boolean canReplace(int x, int y, int z:",
			"return(getBlockState(x, y, z).isIn(REPLACE))",
		")",
		"unless (canReplace(originX, originY, originZ): return(false))",
		"class Pos (",
			"int x",
			"int y",
			"int z",
		")",
		"class MutableBoolean (",
			"boolean value",
		")",

		"boolean spill = random.nextBoolean(SPILL_CHANCE)",
		"int size = random.roundInt(exp(mixLinear(log(4.0L), log(256.0L), random.nextDouble())))",
		"Set lavaPositions = HashSet.new(size)",
		"Set magmaPositions = HashSet.new(size)",
		"List queue = ArrayList.new(size)",
		"(",
			"Pos origin = Pos.new(originX, originY, originZ)",
			"magmaPositions.add(origin)",
			"queue.add(origin)",
		")",

		"MutableBoolean useActualLava = MutableBoolean.new(false)",
		"repeat (size:",
			"if (queue.isEmpty(): break())",
			";see overworld/prismarine for an explanation of how this part works.",
			"int index = random.nextInt(queue.size)",
			"Pos center = (",
				"index == queue.size - 1",
				"? queue.removeIndex(index)",
				": queue.set(index, queue.removeIndex(queue.size - 1))",
			")",
			"random.if (double((center.x - originX) ^ 2 + (center.y - originY) ^ 2 + (center.z - originZ) ^ 2) / 15.0L ^ 2: continue())",

			"if (spill:",
				"magmaPositions.removeElement(center)",
				"lavaPositions.add(center)",
				"void add(int x, int y, int z:",
					"BlockState state = getBlockState(x, y, z)",
					"if (state.isIn(REPLACE):",
						"Pos pos = Pos.new(x, y, z)",
						"if (magmaPositions.add(pos): queue.add(pos))",
					")",
					"else unless (state.hasFullCubeOutline():",
						"useActualLava.value = true",
					")",
				")",
				"add(center.x - 1, center.y, center.z)",
				"add(center.x + 1, center.y, center.z)",
				"add(center.x, center.y - 1, center.z)",
				"add(center.x, center.y + 1, center.z)",
				"add(center.x, center.y, center.z - 1)",
				"add(center.x, center.y, center.z + 1)",
			")",
			"else (",
				"if (",
					"canReplace(center.x - 1, center.y, center.z) &&",
					"canReplace(center.x + 1, center.y, center.z) &&",
					"canReplace(center.x, center.y - 1, center.z) &&",
					"canReplace(center.x, center.y + 1, center.z) &&",
					"canReplace(center.x, center.y, center.z - 1) &&",
					"canReplace(center.x, center.y, center.z + 1)",
				":",
					"void add(int x, int y, int z:",
						"Pos pos = Pos.new(x, y, z)",
						"if (magmaPositions.add(pos): queue.add(pos))",
					")",
					"magmaPositions.removeElement(center)",
					"lavaPositions.add(center)",
					"add(center.x - 1, center.y, center.z)",
					"add(center.x + 1, center.y, center.z)",
					"add(center.x, center.y - 1, center.z)",
					"add(center.x, center.y + 1, center.z)",
					"add(center.x, center.y, center.z - 1)",
					"add(center.x, center.y, center.z + 1)",
				")",
			")",
		")",
		"for (Pos pos in magmaPositions:",
			"setBlockState(pos.x, pos.y, pos.z, 'minecraft:magma_block')",
		")",
		"for (Pos pos in lavaPositions:",
			"setBlockState(pos.x, pos.y, pos.z,",
				"useActualLava.value",
				"? 'minecraft:lava[level=0]'",
				": 'bigglobe:hidden_lava'",
			")",
		")",
		"return(true)"
	],
	"inputs": [
		{ "name": "SPILL_CHANCE", "type": "double"   },
		{ "name": "REPLACE",      "type": "BlockTag" }
	]
}