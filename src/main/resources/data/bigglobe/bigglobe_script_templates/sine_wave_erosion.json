{
	"script": [
		"double cosCurve(double x:",
			"x ^= 2",
			"(1.0L - 16.0L * x) * (1.0L - (16.0L - 4.0L * pi) * x)",
		")",
		"",
		"double approxSin(double x:",
			"x *= 1.0L / tau",
			"x -= floor(x)",
			"x <= 0.5L ? cosCurve(x - 0.25L) : -cosCurve(x - 0.75L)",
		")",
		"",
		"double approxCos(double x:",
			"approxSin(x + pi * 0.5L)",
		")",
		"",
		"double expPoly(double x:",
			"(((x * (1.0L / 24.0L) + (1.0L / 6.0L)) * x + 0.5L) * x + 1.0L) * x + 1.0L",
		")",
		"",
		"double highFrequencyErosion = 0.0L",
		"double  lowFrequencyErosion = 0.0L",
		"",
		"double*(",
			"theta = (worldSeed # 16x1BA7A992B9078D6BUL).nextDouble(tau)",
			"unitX = cos(theta)",
			"unitZ = sin(theta)",
			"goldenTheta = 2.39996322972865332L",
			"goldenCos = cos(goldenTheta)",
			"goldenSin = sin(goldenTheta)",
		")",
		"for (int loop in range[0, 512):",
			"long seed = (worldSeed # 16x974EF90428FF872EUL).newSeed(loop)",
			"double*(",
				"unitXTmp = unitX * goldenCos + unitZ * -goldenSin",
				"unitZTmp = unitX * goldenSin + unitZ *  goldenCos",
			")",
			"unitX = unitXTmp",
			"unitZ = unitZTmp",
			"double*(",
				"phase = (seed := seed.newSeed()).nextDouble(tau)",
				"baseAmplitude = 64.0L / expPoly(loop * (1.0L / 103.0L))",
				"projection = (unitX * x + unitZ * z) + phase",
				"adjustedAmplitude = ((unitX * -DZ + unitZ * DX) / (sqrt(DX ^ 2 + DZ ^ 2) + 4.0)) ^ 2",
				"tmpSin = approxSin(projection / baseAmplitude) * baseAmplitude * adjustedAmplitude",
				"tmpCos = approxCos(projection / baseAmplitude) * adjustedAmplitude",
			")",
			"DX += tmpCos * unitX",
			"DZ += tmpCos * unitZ",
			"highFrequencyErosion += tmpSin",
			"if (loop < 256: lowFrequencyErosion += tmpSin)",
		")",
		"return(ErosionNoise.new(highFrequencyErosion, lowFrequencyErosion))"
	],
	"inputs": [
		{ "name": "DX", "type": "double" },
		{ "name": "DZ", "type": "double" }
	]
}