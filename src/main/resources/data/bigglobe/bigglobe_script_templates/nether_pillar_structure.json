{
	"script": [
		"int pillarCount = random.roundInt(PILLARS_PER_CHUNK)",
		"repeat (pillarCount:",
			"repeat centerAttempt (CENTER_ATTEMPTS:",
				"int centerY = random.nextInt(`bigglobe:nether/min_y`, `bigglobe:nether/max_y`)",
				"unless (`bigglobe:nether/bubble`.noise(centerY) < 0.5I:",
					"continue(centerAttempt)",
				")",
				"double angle = random.nextDouble(tau)",
				"double radius = random.nextDouble(1.0L, MAX_RADIUS)",
				"double dx = cos(angle) * radius",
				"double dz = sin(angle) * radius",

				"int posX = originX + int(dx)",
				"int posZ = originZ + int(dz)",
				"int posY = centerY",
				"while (`bigglobe:nether/bubble`(posX, posZ).noise(posY) < 0.5I:",
					"if (:++ posY >= `bigglobe:nether/max_y`: continue(centerAttempt))",
				")",

				"int negX = originX - int(dx)",
				"int negZ = originZ - int(dz)",
				"int negY = centerY",
				"while (`bigglobe:nether/bubble`(negX, negZ).noise(negY) < 0.5I:",
					"if (:-- negY < `bigglobe:nether/min_y`: continue(centerAttempt))",
				")",

				"double normX = posX - negX",
				"double normY = posY - negY",
				"double normZ = posZ - negZ",
				"double length = sqrt(normX ^ 2 + normY ^ 2 + normZ ^ 2)",
				"double endRadius = random.nextDouble(0.5L, 1.0L) * sqrt(length)",

				"posY += ceilInt(endRadius)",
				"unless (",
					"posY + ceilInt(endRadius) < `bigglobe:nether/max_y` &&",
					"`bigglobe:nether/bubble`(posX, posZ).noise(posY + ceilInt(endRadius)) >= 0.5I",
				":",
					"continue(centerAttempt)",
				")",

				"negY -= ceilInt(endRadius)",
				"unless (",
					"negY - ceilInt(endRadius) >= `bigglobe:nether/min_y` &&",
					"`bigglobe:nether/bubble`(negX, negZ).noise(negY - ceilInt(endRadius)) >= 0.5I",
				":",
					"continue(centerAttempt)",
				")",

				"centerY = (posY + negY) >> 1",
				"unless (`bigglobe:nether/bubble`.noise(centerY) < 0.5I:",
					"continue(centerAttempt)",
				")",

				";posY and negY changed, so recompute norm and length.",
				"normX = posX - negX",
				"normY = posY - negY",
				"normZ = posZ - negZ",
				"length = sqrt(normX ^ 2 + normY ^ 2 + normZ ^ 2)",

				"double scalar = 1.0L / length",
				"normX *= scalar",
				"normY *= scalar",
				"normZ *= scalar",
				"double centerRadius = random.nextDouble(0.25L, 0.5L) * endRadius",
				"random.if (BROKEN_CHANCE: centerRadius *= -0.5L)",
				"pieces.add(",
					"ScriptStructurePiece.new(",
						"min(posX, negX) -  ceilInt(endRadius * 2.0L),",
						"min(posY, negY) -  ceilInt(endRadius * 2.0L),",
						"min(posZ, negZ) -  ceilInt(endRadius * 2.0L),",
						"max(posX, negX) + floorInt(endRadius * 2.0L),",
						"max(posY, negY) + floorInt(endRadius * 2.0L),",
						"max(posZ, negZ) + floorInt(endRadius * 2.0L),",
						"'bigglobe:nether_pillar',",
						"nbtCompound(",
							"posX: posX,",
							"posY: posY,",
							"posZ: posZ,",
							"negX: negX,",
							"negY: negY,",
							"negZ: negZ,",
							"normX: normX,",
							"normY: normY,",
							"normZ: normZ,",
							"length: length,",
							"endR: endRadius,",
							"centerR: centerRadius",
						")",
					")",
				")",
				"break(centerAttempt)",
			")",
		")"
	],
	"inputs": [
		{ "name": "PILLARS_PER_CHUNK", "type": "float"  },
		{ "name": "CENTER_ATTEMPTS",   "type": "int"    },
		{ "name": "MAX_RADIUS",        "type": "double" },
		{ "name": "BROKEN_CHANCE",     "type": "float"  }
	]
}