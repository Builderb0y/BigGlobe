{
	"type": "bigglobe:script",
	"config": {
		"script": [
			"class Column (int x,, int z)",
			"class Height (int y)",
			"void placeColumn(MapEntry entry:",
				"Column column = entry.key",
				"Height height = entry.value",
				"int x = column.x",
				"int z = column.z",
				"void fill(int minY, int maxY:",
					"for (int y = minY, y <= maxY, ++y:",
						"if (getBlockState(x, y, z).isReplaceable():",
							"setBlockState(x, y, z, 'minecraft:obsidian')",
						")",
						"else (",
							"abort()",
						")",
					")",
				")",
				"double thickness = `end/mountain_thickness`(x, z)",
				"unless (thickness > 0.0L: abort())",
				"double centerY = `end/mountain_center_y`(x, z)",
				"int minY = ceilInt(centerY + thickness)",
				"int maxY = minY + height.y",
				"fill(minY, maxY - 1)",
				"maxY = floorInt(centerY - thickness) - 1",
				"minY = maxY - height.y",
				"fill(minY + 1, maxY)",
			")",

			"double maxHeightD = random.nextDouble(16.0L, 64.0L)",
			"int maxHeightI = random.roundInt(maxHeightD)",
			"double standardDeviation = sqrt(maxHeightD * 0.125L)",

			";generate initial heights above lava level.",
			";the 'heights' map maps Columns to Heights.",
			"Map heights = HashMap.new()",
			"Column column = Column.new()",
			"until (Height height = heights.(column.x = originX,, column.z = originZ,, column),, height != null && height.y >= maxHeightI:",
				"column.x = roundInt(random.nextGaussian(column.x, standardDeviation))",
				"column.z = roundInt(random.nextGaussian(column.z, standardDeviation))",
				"if ((column.x - originX) ^ 2 + (column.z - originZ) ^ 2 > max(standardDeviation * 4.0L, 2.0L) ^ 2: continue())",
				"height = heights.(column)",
				"if (height != null: ++height.y)",
				"else (heights.(Column.new(column.x, column.z)) = Height.new(0))",
			")",

			";place blocks.",
			"for (MapEntry entry in heights.entrySet():",
				"placeColumn(entry)",
			")",

			";place gateway.",
			"random.if (1.0 / 4.0:",
				"int rand = random.nextInt(6)",
				"int upperMinY = ceilInt(max_y(originX, originZ)) + maxHeightI + rand",
				"int lowerMaxY = ceilInt(min_y(originX, originZ)) - 1 - maxHeightI - rand",
				"if (",
					"getBlockState(originX - 1, upperMinY, originZ    ).isAir() &&",
					"getBlockState(originX + 1, upperMinY, originZ    ).isAir() &&",
					"getBlockState(originX,     upperMinY, originZ - 1).isAir() &&",
					"getBlockState(originX,     upperMinY, originZ + 1).isAir() &&",

					"getBlockState(originX - 1, lowerMaxY, originZ    ).isAir() &&",
					"getBlockState(originX + 1, lowerMaxY, originZ    ).isAir() &&",
					"getBlockState(originX,     lowerMaxY, originZ - 1).isAir() &&",
					"getBlockState(originX,     lowerMaxY, originZ + 1).isAir()",
				":",
					"placeFeature(originX, upperMinY + 3, originZ, 'bigglobe:end/gateway_return')",
					"placeFeature(originX, lowerMaxY - 3, originZ, 'bigglobe:end/gateway_return')",
				")",
			")",

			"return(true)"
		],
		"queue": "basic"
	}
}