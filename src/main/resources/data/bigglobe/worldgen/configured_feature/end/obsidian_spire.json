{
	"type": "bigglobe:script",
	"config": {
		"script": {
			"debug_name": "ConfiguredFeatureEndObsidianSpire",
			"source": [
				"class Column (int*(x, z))",
				"Column Column.at(int*(x, z):",
					"this.=$x(x).=$z(z)",
				")",
				"class Height (int y)",
				"void placeColumn(Column column, Height height:",
					"int*(x = column.x, z = column.z)",
					"void fill(int minY, int maxY:",
						"for (int y in range[minY, maxY]:",
							"if (getBlockState(x, y, z).isReplaceable():",
								"setBlockState(x, y, z, 'minecraft:obsidian')",
							")",
							"else (",
								"abort()",
							")",
						")",
					")",
					"unless (`bigglobe:end/has_mountain`(x, z): abort())",
					"int minY = higherInt(`bigglobe:end/mountain_max_y`(x, z))",
					"int maxY = minY + height.y",
					"fill(minY, maxY - 1)",
					"maxY = floorInt(`bigglobe:end/mountain_min_y`(x, z)) - 1",
					"minY = maxY - height.y",
					"fill(minY + 1, maxY)",
				")",

				"double maxHeightD = random.nextDouble(16.0L, 64.0L)",
				"int maxHeightI = random.roundInt(maxHeightD)",
				"double standardDeviation = sqrt(maxHeightD * 0.125L)",

				";generate initial heights above lava level.",
				";the 'heights' map maps Columns to Heights.",
				"HashMap heights = new()",
				"Column column = new()",
				"until (Height height = heights.(column.at(originX, originZ)),, height != null && height.y >= maxHeightI:",
					"column.x = roundInt(random.nextGaussian(column.x, standardDeviation))",
					"column.z = roundInt(random.nextGaussian(column.z, standardDeviation))",
					"if ((column.x - originX) ^ 2 + (column.z - originZ) ^ 2 > max(standardDeviation * 4.0L, 2.0L) ^ 2: continue())",
					"height = heights.(column)",
					"if (height != null: ++height.y)",
					"else (heights.(Column.new(column.x, column.z)) = Height.new(0))",
				")",

				";place blocks.",
				"for (Column c, Height height in heights:",
					"placeColumn(c, height)",
				")",

				";place gateway.",
				"random.if (1.0 / 4.0:",
					"int rand = random.nextInt(6)",
					"int upperMinY = ceilInt(`bigglobe:end/mountain_max_y`(originX, originZ)) + maxHeightI + rand",
					"int lowerMaxY = ceilInt(`bigglobe:end/mountain_min_y`(originX, originZ)) - 1 - maxHeightI - rand",
					"if (",
						"getBlockState(originX - 1, upperMinY, originZ    ).isAir() &&",
						"getBlockState(originX + 1, upperMinY, originZ    ).isAir() &&",
						"getBlockState(originX,     upperMinY, originZ - 1).isAir() &&",
						"getBlockState(originX,     upperMinY, originZ + 1).isAir() &&",

						"getBlockState(originX - 1, lowerMaxY, originZ    ).isAir() &&",
						"getBlockState(originX + 1, lowerMaxY, originZ    ).isAir() &&",
						"getBlockState(originX,     lowerMaxY, originZ - 1).isAir() &&",
						"getBlockState(originX,     lowerMaxY, originZ + 1).isAir()",
					":",
						"placeFeature(originX, upperMinY + 3, originZ, 'bigglobe:end/gateway_return')",
						"placeFeature(originX, lowerMaxY - 3, originZ, 'bigglobe:end/gateway_return')",
					")",
				")",

				"return(true)"
			]
		},
		"queue": "basic"
	}
}