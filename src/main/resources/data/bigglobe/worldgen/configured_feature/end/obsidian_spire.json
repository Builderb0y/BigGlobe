{
	"type": "bigglobe:script",
	"config": {
		"script": [
			"class Column (int x,, int z)",
			"class Height (int y)",
			"int findGround(int x, int z:",
				"return(`end/mountain_thickness`(x, z) > 0.0L ? ceilInt(`max_y`(x, z)) : -2147483648)",
			")",
			"boolean checkColumn(MapEntry entry:",
				"Column column = entry.key",
				"Height height = entry.value",
				"int x = column.x",
				"int z = column.z",
				"int minY = findGround(x, z)",
				"if (minY == -2147483648: return(false))",
				"int maxY = minY + height.y",
				"for (int y = minY, y < maxY, ++y:",
					"unless (getBlockState(x, y, z).isReplaceable(): return(false))",
				")",
				"return(true)",
			")",
			"void placeColumn(MapEntry entry:",
				"Column column = entry.key",
				"Height height = entry.value",
				"int x = column.x",
				"int z = column.z",
				"int minY = findGround(x, z)",
				"if (minY == -2147483648: return())",
				"int maxY = minY + height.y",
				"for (int y = minY, y < maxY, ++y:",
					"setBlockState(x, y, z, 'minecraft:obsidian')",
				")",
			")",

			"double maxHeightD = random.nextDouble(16.0L, 64.0L)",
			"int maxHeightI = random.roundInt(maxHeightD)",
			"double standardDeviation = sqrt(maxHeightD * 0.125L)",

			";generate initial heights above lava level.",
			";the 'heights' map maps Columns to Heights.",
			"Map heights = HashMap.new()",
			"Column column = Column.new()",
			"while ((Height height = heights.(column.x = originX,, column.z = originZ,, column),, height == null || height.y < maxHeightI):",
				"column.x = roundInt(random.nextGaussian(column.x, standardDeviation))",
				"column.z = roundInt(random.nextGaussian(column.z, standardDeviation))",
				"if ((column.x - originX) ^ 2 + (column.z - originZ) ^ 2 > max(standardDeviation * 4.0L, 2.0L) ^ 2: continue())",
				"Height height = heights.(column)",
				"if (height != null: ++height.y)",
				"else (heights.(Column.new(column.x, column.z)) = Height.new(0))",
			")",

			";check area to make sure we have enough space to generate.",
			"for (MapEntry entry in heights.entrySet():",
				"unless (checkColumn(entry): return(false))",
			")",

			";place blocks.",
			"for (MapEntry entry in heights.entrySet():",
				"placeColumn(entry)",
			")",

			";place gateway.",
			"random.if (1.0 / 4.0:",
				"int gatewayMinY = originY + maxHeightI + random.nextInt(6)",
				"if (",
					"getBlockState(originX - 1, gatewayMinY, originZ    ).isAir() &&",
					"getBlockState(originX + 1, gatewayMinY, originZ    ).isAir() &&",
					"getBlockState(originX,     gatewayMinY, originZ - 1).isAir() &&",
					"getBlockState(originX,     gatewayMinY, originZ + 1).isAir()",
				":",
					"placeFeature(originX, gatewayMinY + 3, originZ, 'bigglobe:end/gateway_return')",
				")",
			")",

			"return(true)"
		]
	}
}