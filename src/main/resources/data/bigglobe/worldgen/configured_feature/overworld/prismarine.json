{
	"type": "bigglobe:script",
	"config": {
		"script": [
			"class Pos (",
				"int x",
				"int y",
				"int z",
			")",
			"int size = random.roundInt(exp(mixLinear(log(4.0), log(64.0), random.nextDouble())))",
			"double chance = random.nextDouble(0.25, 0.75)",
			"Set positions = HashSet.new(size)",
			"List queue = ArrayList.new(size)",
			"Pos origin = Pos.new(originX, originY, originZ)",
			"queue.add(origin)",
			"positions.add(origin)",

			";;",
			"we generate this feature by repeatedly picking a random position from positions,",
			"and 'expanding' it, by adding its neighbors to positions too.",
			"we want to avoid expanding the same position more than once,",
			"which is why we have queue. all the positions which haven't",
			"been expanded yet are in queue. so really, I guess it would be more",
			"accurate to say we repeatedly expand a random position from queue.",
			";;",
			"repeat (size:",
				";;",
				"remove a random element from queue.",
				"we could just call queue.remove(random.nextInt(queue.size())),",
				"but this would be slow since all subsequent",
				"elements would need to be shifted down one index.",
				"instead what we do here is remove a random element,",
				"but replace it with the last element.",
				"that way, only the last element needs to be moved.",
				"if we randomly choose to remove the last element,",
				"then nothing needs to be moved.",
				";;",
				"int index = random.nextInt(queue.size())",
				"Pos center = (",
					"index == queue.size() - 1",
					"? queue.remove(index)",
					": queue.set(index, queue.remove(queue.size() - 1))",
				")",

				";;",
				"add all 6 neighbors of center to positions.",
				"if any of them are NOT already present,",
				"then add them to queue too.",
				";;",
				"Pos offset = Pos.new(center.x + 1, center.y, center.z)",
				"if (positions.add(offset): queue.add(offset))",
				"offset = Pos.new(center.x - 1, center.y, center.z)",
				"if (positions.add(offset): queue.add(offset))",
				"offset = Pos.new(center.x, center.y + 1, center.z)",
				"if (positions.add(offset): queue.add(offset))",
				"offset = Pos.new(center.x, center.y - 1, center.z)",
				"if (positions.add(offset): queue.add(offset))",
				"offset = Pos.new(center.x, center.y, center.z + 1)",
				"if (positions.add(offset): queue.add(offset))",
				"offset = Pos.new(center.x, center.y, center.z - 1)",
				"if (positions.add(offset): queue.add(offset))",
			")",

			";count up how many solid blocks we are trying to generate through.",
			"int solidCount = 0",
			"for (Pos pos in positions:",
				"if (getBlockState(pos.x, pos.y, pos.z).hasFullCubeCollision():",
					"++solidCount",
				")",
			")",

			";if more than half of the blocks we are trying to",
			";generate through are not solid, don't place any blocks.",
			"if (solidCount < (positions.size() >> 1): return(false))",

			";otherwise, place all the blocks now.",
			"for (Pos pos in positions:",
				"setBlockState(pos.x, pos.y, pos.z, random.if ('bigglobe:crystalline_prismarine') else ('minecraft:prismarine'))",
			")",

			"return(true)"
		]
	}
}