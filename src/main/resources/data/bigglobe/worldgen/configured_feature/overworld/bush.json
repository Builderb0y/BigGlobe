{
	"type": "bigglobe:script",
	"config": {
		"script": {
			"debug_name": "ConfiguredFeatureOverworldBush",
			"source": [
				";handle caves that intersect the surface.",
				"while (isYLevelValid(originY - 1) && getBlockState(originX, originY - 1, originZ).isReplaceable():",
					"--originY",
				")",
				"unless (",
					"BlockState tmp = getBlockState(originX, originY - 1, originZ),,",
					"(tmp.isIn('minecraft:dirt') || tmp.isIn('minecraft:sand')) &&",
					"getBlockState(originX, originY, originZ).isReplaceable()",
				":",
					"return(false)",
				")",
				"boolean BlockState.canLeavesReplace(:",
					"return(this.isReplaceable() || this.isIn('bigglobe:tree_leaf_replaceables'))",
				")",
				"WoodPalette palette = `bigglobe:overworld/wood_palette`",
				"if (palette == null: return(false))",
				"setBlockState(originX, originY, originZ, palette.woodState(axis: 'y'))",
				"double centerX = originX + random.nextDouble() - 0.5L",
				"double centerZ = originZ + random.nextDouble() - 0.5L",
				"double radiusH = random.nextDouble(1.0L, 3.0L)",
				"double radiusV = random.nextDouble(1.0L, 2.0L)",
				"double rcpH = 1.0L / radiusH",
				"double rcpV = 1.0L / radiusV",
				"double snowChance = `bigglobe:overworld/snow_chance`",
				"for (",
					"int z in range[ceilInt(centerZ - radiusH), floorInt(centerZ + radiusH)],",
					"int x in range[ceilInt(centerX - radiusH), floorInt(centerX + radiusH)]",
				":",
					"double distXZ2 = ((x - centerX) * rcpH) ^ 2 + ((z - centerZ) * rcpH) ^ 2",
					"unless (distXZ2 < 1.0L: continue())",
					"BlockState existingState = getBlockState(x, originY, z)",
					"if (existingState.canLeavesReplace() && !existingState.hasFluid():",
						"setBlockState(x, originY, z, palette.leavesState(distance: abs(x - originX) + abs(z - originZ), persistent: false, waterlogged: false))",
					")",
					"int snowY = originY + 1",
					"if (distXZ2 + rcpV ^ 2 < 1.0L:",
						"existingState = getBlockState(x, snowY, z)",
						"if (existingState.canLeavesReplace() && !existingState.hasFluid():",
							"setBlockState(x, snowY, z, palette.leavesState(distance: abs(x - originX) + abs(z - originZ) + 1, persistent: false, waterlogged: false))",
							"++snowY",
						")",
					")",
					"existingState = getBlockState(x, snowY, z)",
					"if (existingState.canLeavesReplace() && !existingState.hasFluid() && existingState.getBlock() != Block('minecraft:snow') && random.nextBoolean(snowChance):",
						"setBlockState(x, snowY, z, 'minecraft:snow[layers=1]')",
					")",
				")",
				"return(true)"
			]
		}
	}
}