{
	"type": "bigglobe:script",
	"config": {
		"script": {
			"debug_name": "ConfiguredFeatureOverworldBush",
			"source": [
				";handle caves that intersect the surface.",
				"while (isYLevelValid(originY - 1) && getBlockState(originX, originY - 1, originZ).isReplaceable():",
					"--originY",
				")",
				"unless (",
					"BlockState tmp = getBlockState(originX, originY - 1, originZ),,",
					"(tmp.isIn('minecraft:dirt') || tmp.isIn('minecraft:sand')) &&",
					"getBlockState(originX, originY, originZ).isReplaceable()",
				":",
					"return(false)",
				")",
				"boolean BlockState.canLeavesReplace(:",
					"return(this.isReplaceable() || this.isIn('bigglobe:tree_leaf_replaceables'))",
				")",
				"WoodPalette palette = WoodPalette.randomForBiome(getBiome(originX, originY, originZ))",
				"if (palette == null: return(false))",
				"setBlockState(originX, originY, originZ, palette.woodState(axis: 'y'))",
				"double centerX = originX + random.nextDouble() - 0.5L",
				"double centerZ = originZ + random.nextDouble() - 0.5L",
				"double radiusH = random.nextDouble(1.0L, 3.0L)",
				"double radiusV = random.nextDouble(1.0L, 2.0L)",
				"double rcpH = 1.0L / radiusH",
				"double rcpV = 1.0L / radiusV",
				"int minX =  ceilInt(centerX - radiusH)",
				"int minZ =  ceilInt(centerZ - radiusH)",
				"int maxX = floorInt(centerX + radiusH)",
				"int maxZ = floorInt(centerZ + radiusH)",
				"double snowChance = `overworld/snow_chance`",
				"for (int z = minZ, z <= maxZ, ++z:",
					"for (int x = minX, x <= maxX, ++x:",
						"double distXZ2 = ((x - centerX) * rcpH) ^ 2 + ((z - centerZ) * rcpH) ^ 2",
						"unless (distXZ2 < 1.0L: continue())",
						"BlockState existingState = getBlockState(x, originY, z)",
						"if (existingState.canLeavesReplace() && !existingState.hasFluid():",
							"setBlockState(x, originY, z, palette.leavesState(distance: abs(x - originX) + abs(z - originZ), persistent: false, waterlogged: false))",
						")",
						"int snowY = originY + 1",
						"if (distXZ2 + rcpV ^ 2 < 1.0L:",
							"existingState = getBlockState(x, snowY, z)",
							"if (existingState.canLeavesReplace() && !existingState.hasFluid():",
								"setBlockState(x, snowY, z, palette.leavesState(distance: abs(x - originX) + abs(z - originZ) + 1, persistent: false, waterlogged: false))",
								"++snowY",
							")",
						")",
						"existingState = getBlockState(x, snowY, z)",
						"if (existingState.canLeavesReplace() && !existingState.hasFluid() && existingState.getBlock() != Block('minecraft:snow') && random.nextBoolean(snowChance):",
							"setBlockState(x, snowY, z, 'minecraft:snow[layers=1]')",
						")",
					")",
				")",
				"return(true)"
			]
		}
	}
}