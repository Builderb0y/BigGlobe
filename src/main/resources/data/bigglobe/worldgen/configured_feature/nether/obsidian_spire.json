{
	"type": "bigglobe:script",
	"config": {
		"script": {
			"debug_name": "ConfiguredFeatureNetherObsidianSpire",
			"source": [
				"boolean canReplace(int*(x, y, z):",
					"BlockState state = getBlockState(x, y, z)",
					"return(state.isReplaceable() || (state.isIn('bigglobe:magma_blocks') && y == int(`bigglobe:nether/bubble`.lava_level) - 1))",
				")",

				"class Column (int*(x, z))",
				"Column Column.at(int*(x, z):",
					"this.=$x(x).=$z(z)",
				")",
				"class Height (int y)",

				"double maxHeightD = 1.0L - `bigglobe:nether/bubble`.soft_distance",
				"maxHeightD *= exp2(random.nextDouble(3.0L, 7.0L))",
				"int maxHeightI = random.roundInt(maxHeightD) + originY",
				"double standardDeviation = sqrt(maxHeightD * 0.125L)",

				";generate initial heights above lava level.",
				";the 'heights' map maps Columns to Heights.",
				"HashMap heights = new()",
				"Column column = new()",
				"while (Height height = heights.(column.at(originX, originZ)),, height == null || height.y < maxHeightI:",
					"column.x = int(random.nextGaussian(column.x + 0.5L, standardDeviation))",
					"column.z = int(random.nextGaussian(column.z + 0.5L, standardDeviation))",
					"if ((column.x - originX) ^ 2 + (column.z - originZ) ^ 2 > max(standardDeviation * 4.0L, 2.0L) ^ 2: continue())",
					"height = heights.(column)",
					"if (height != null: ++height.y)",
					"else (heights.(Column.new(column.x, column.z)) = Height.new(originY))",
				")",

				";check area to make sure we have enough space to generate.",
				"for (Column c, Height height in heights:",
					"int*(x = c.x, z = c.z)",
					"for (int y in range[originY - 1, height.y]:",
						"unless (canReplace(x, y, z): return(false))",
					")",
				")",

				";sort columns by height.",
				"TreeMap queue = new()",
				"for (Column c, Height height in heights:",
					"Integer startY = height.y",
					"LinkedList list = queue.(startY)",
					"if (list == null:",
						"list = new()",
						"queue.(startY) = list",
					")",
					"list.add(c)",
				")",

				";process each column.",
				"void updateHeight(int*(x, startY, z):",
					"unless (isPositionValid(x, startY, z): return())",
					"if (heights.containsKey(column.at(x, z)): return())",
					"--startY",
					"int endY = startY",
					"while (isYLevelValid(endY) && canReplace(x, endY, z): --endY)",
					"++endY",
					"if (startY > endY:",
						"Integer y = random.nextInt(endY, startY)",
						"LinkedList list = queue.(y)",
						"if (list == null:",
							"list = new()",
							"queue.(y) = list",
						")",
						"list.add(Column.new(x, z))",
					")",
				")",
				"until (queue.isEmpty():",
					"MapEntry entry = queue.pollLastEntry()",
					"int startY = entry.key",
					"for (Column c in LinkedList(entry.value):",
						"int x = c.x",
						"int z = c.z",
						"for (int y = startY - 1, isYLevelValid(y) && canReplace(x, y, z), --y:",
							"setBlockState(x, y, z, 'minecraft:obsidian')",
						")",
						"if (startY >= originY && random.nextBoolean(0.125L):",
							"setBlockState(x, startY, z, 'minecraft:fire[north=false,south=false,east=false,west=false,up=false,age=0]')",
						")",
						"updateHeight(x + 1, startY, z)",
						"updateHeight(x - 1, startY, z)",
						"updateHeight(x, startY, z + 1)",
						"updateHeight(x, startY, z - 1)",
					")",
				")",

				";place spawner.",
				"random.if (maxHeightD / 128.0L:",
					"setBlockState(originX, maxHeightI, originZ, 'minecraft:spawner')",
					"mergeBlockData(originX, maxHeightI, originZ, nbtCompound(",
						"SpawnData: nbtCompound(",
							"entity: nbtCompound(",
								"id: 'minecraft:ghast'",
							")",
						"),",
						"SpawnCount: short(1),",
						"MaxNearbyEntities: short(2),",
						"MinSpawnDelay: short(100),",
						"MaxSpawnDelay: short(500),",
						"SpawnRange: short(maxHeightD),",
						"RequiredPlayerRange: short(maxHeightD),",
						"bigglobe_SpawnLightning: true",
					"))",
				")",

				"return(true)"
			]
		}
	}
}