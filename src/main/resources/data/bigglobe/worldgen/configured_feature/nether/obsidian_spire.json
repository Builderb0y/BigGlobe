{
	"type": "bigglobe:script",
	"config": {
		"script": [
			"boolean canReplace(int x, int y, int z:",
				"BlockState state = getBlockState(x, y, z)",
				"return(state.isReplaceable() || (state.isIn('bigglobe:magma_blocks') && y == int(`nether/lava_level`) - 1))",
			")",

			"double maxHeightD = 1.0L - `nether/biome_edginess`",
			"maxHeightD *= exp2(random.nextDouble(3.0L, 7.0L))",
			"int maxHeightI = random.roundInt(maxHeightD) + originY",
			"double maxRadiusD = maxHeightD * exp2(random.nextDouble(-3.0L, -1.0L))",

			";generate initial heights above lava level.",
			";the 'heights' map maps Columns to Heights.",
			"class Column (int x,, int z)",
			"class Height (int y)",
			"Map heights = HashMap.new()",
			"Column column = Column.new()",
			"while ((Height height = heights.get(column.x = originX,, column.z = originZ,, column),, height == null || height.y < maxHeightI):",
				"int maxRadiusI = random.roundInt(maxRadiusD)",
				"repeat (maxRadiusI:",
					";2 in 6 chance of not moving is 100% intentional.",
					"random.switch (++column.x, --column.x, ++column.z, --column.z, noop, noop)",
				")",
				"Height height = heights.(column)",
				"if (height != null: ++height.y)",
				"else (heights.(Column.new(column.x, column.z)) = Height.new(originY))",
			")",

			";check area to make sure we have enough space to generate.",
			"for (MapEntry entry in heights.entrySet():",
				"Column c = entry.key",
				"Height height = entry.value",
				"int x = c.x",
				"int z = c.z",
				"int maxY = height.y",
				"for (int y = originY - 1, y <= maxY, ++y:",
					"unless (canReplace(x, y, z): return(false))",
				")",
			")",

			";sort columns by height.",
			"TreeMap queue = TreeMap.new()",
			"for (MapEntry entry in heights.entrySet():",
				"Integer startY = Height(entry.value).y",
				"LinkedList list = queue.(startY)",
				"if (list == null:",
					"list = LinkedList.new()",
					"queue.(startY) = list",
				")",
				"list.add(entry.key)",
			")",

			";process each column.",
			"void updateHeight(int x, int startY, int z:",
				"if (heights.containsKey(column.x = x,, column.z = z,, column): return())",
				"--startY",
				"int endY = startY",
				"while (isYLevelValid(endY) && canReplace(x, endY, z): --endY)",
				"++endY",
				"if (startY > endY:",
					"Integer y = random.nextInt(endY, startY)",
					"LinkedList list = queue.(y)",
					"if (list == null:",
						"list = LinkedList.new()",
						"queue.(y) = list",
					")",
					"list.add(Column.new(x, z))",
				")",
			")",
			"until (queue.isEmpty():",
				"MapEntry entry = queue.pollLastEntry()",
				"int startY = entry.key",
				"for (Column c in LinkedList(entry.value):",
					"int x = c.x",
					"int z = c.z",
					"for (int y = startY - 1, isYLevelValid(y) && canReplace(x, y, z), --y:",
						"setBlockState(x, y, z, 'minecraft:obsidian')",
					")",
					"if (startY >= originY && random.nextBoolean(0.125L):",
						"setBlockState(x, startY, z, 'minecraft:fire[north=false,south=false,east=false,west=false,up=false,age=0]')",
					")",
					"updateHeight(x + 1, startY, z)",
					"updateHeight(x - 1, startY, z)",
					"updateHeight(x, startY, z + 1)",
					"updateHeight(x, startY, z - 1)",
				")",
			")",

			";place spawner.",
			"random.if (maxHeightD / 128.0L:",
				"setBlockState(originX, maxHeightI, originZ, 'minecraft:spawner')",
				"mergeBlockData(originX, maxHeightI, originZ, nbtCompound(",
					"SpawnData: nbtCompound(",
						"entity: nbtCompound(",
							"id: 'minecraft:ghast'",
						")",
					"),",
					"SpawnCount: short(1),",
					"MaxNearbyEntities: short(2),",
					"MinSpawnDelay: short(100),",
					"MaxSpawnDelay: short(500),",
					"SpawnRange: short(maxHeightD),",
					"RequiredPlayerRange: short(maxHeightD),",
					"bigglobe_SpawnLightning: true",
				"))",
			")",

			"return(true)"
		]
	}
}