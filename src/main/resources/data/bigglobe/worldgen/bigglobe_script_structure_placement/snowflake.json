{
	"raw_placement": [
		"int*(",
			"rawScale = data.scale.asInt()",
			"diameter = 3 ^ rawScale",
			"iterMinX = max(minX, chunkMinX)",
			"iterMinY = max(minY, chunkMinY)",
			"iterMinZ = max(minZ, chunkMinZ)",
			"iterMaxX = min(maxX, chunkMaxX)",
			"iterMaxY = min(maxY, chunkMaxY)",
			"iterMaxZ = min(maxZ, chunkMaxZ)",
		")",
		"boolean hollow = data.hollow.asBoolean()",
		"BlockState state = data.state.asString().as(BlockState)",
		"for positionLoop (",
			"int y in range[iterMinY, iterMaxY],",
			"int z in range[iterMinZ, iterMaxZ],",
			"int x in range[iterMinX, iterMaxX]",
		":",
			"int*(",
				"iterX = x - midX",
				"iterY = y - midY",
				"iterZ = z - midZ",
				"scale = diameter",
			")",
			"repeat (rawScale:",
				"int*(scale3 = scale / 3, scale6 = scale3 >> 1)",
				"int sum = (",
					"+ int(abs(iterX) <= scale6)",
					"+ int(abs(iterY) <= scale6)",
					"+ int(abs(iterZ) <= scale6)",
				")",
				"switch (sum:",
					"case (0: continue(positionLoop))",
					"case (3: if (hollow: continue(positionLoop)))",
					"default (noop)",
				")",
				"if      (iterX >  scale6: iterX -= scale3)",
				"else if (iterX < -scale6: iterX += scale3)",
				"if      (iterY >  scale6: iterY -= scale3)",
				"else if (iterY < -scale6: iterY += scale3)",
				"if      (iterZ >  scale6: iterZ -= scale3)",
				"else if (iterZ < -scale6: iterZ += scale3)",
				"scale = scale3",
			")",
			"setBlockState(x, y, z, state)",
		")"
	],
	"placement": "noop"
}