{
	"raw_placement": [
		"int*(",
			"originX  = data.x.asInt()",
			"originY  = data.y.asInt()",
			"originZ  = data.z.asInt()",
			"type     = data.type.asInt()",
			"rawScale = data.scale.asInt()",
			"diameter = 3 ^ rawScale",
			"iterMinX = max(minX, chunkMinX)",
			"iterMinY = max(minY, chunkMinY)",
			"iterMinZ = max(minZ, chunkMinZ)",
			"iterMaxX = min(maxX, chunkMaxX)",
			"iterMaxY = min(maxY, chunkMaxY)",
			"iterMaxZ = min(maxZ, chunkMaxZ)",
		")",
		"BlockState state = data.state.asString().as(BlockState)",
		"for positionLoop (",
			"int y in range[iterMinY, iterMaxY],",
			"int z in range[iterMinZ, iterMaxZ],",
			"int x in range[iterMinX, iterMaxX]",
		":",
			"int*(",
				"iterX = x - originX",
				"iterY = y - originY",
				"iterZ = z - originZ",
				"scale = diameter",
			")",
			"boolean corner = false",
			"repeat (rawScale:",
				"int*(scale3 = scale / 3, scale6 = scale3 >> 1)",
				"if (type & 1 != 0 && max(abs(iterX), abs(iterY), abs(iterZ)) < scale3:",
					"continue(positionLoop)",
				")",
				"int sum = (",
					"+ int(abs(iterX) <= scale6)",
					"+ int(abs(iterY) <= scale6)",
					"+ int(abs(iterZ) <= scale6)",
				")",
				"if (sum == 0: corner = true)",
				"if (sum >= (type & 2 != 0 && !corner && scale3 == 1 ? 1 : 2):",
					"continue(positionLoop)",
				")",
				"if      (iterX >  scale6: iterX -= scale3)",
				"else if (iterX < -scale6: iterX += scale3)",
				"if      (iterY >  scale6: iterY -= scale3)",
				"else if (iterY < -scale6: iterY += scale3)",
				"if      (iterZ >  scale6: iterZ -= scale3)",
				"else if (iterZ < -scale6: iterZ += scale3)",
				"scale = scale3",
			")",
			"setBlockState(x, y, z, state)",
		")"
	],
	"placement": "noop"
}