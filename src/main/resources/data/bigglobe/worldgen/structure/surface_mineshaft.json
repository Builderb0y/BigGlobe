{
	"type": "bigglobe:script",
	"value": {
		"biomes": "#bigglobe:has_structure/well",
		"spawn_overrides": {},
		"step": "surface_structures",
		"layout": {
			"script": [
				"void positionPiece(ScriptStructurePiece from, ScriptStructurePiece to:",
					"if (from.placement == StructurePlacementScript('bigglobe:surface_mineshaft/staircase'):",
						"to.rotateAround(0, 0, from.rotation)",
						"switch (from.rotation:",
							"case(  0: to.offset(from.maxX + 1, from.minY, from.midZ    ))",
							"case( 90: to.offset(from.midX,     from.minY, from.maxZ + 1))",
							"case(180: to.offset(from.minX - 1, from.minY, from.midZ    ))",
							"case(270: to.offset(from.midX,     from.minY, from.minZ - 1))",
						")",
					")",
					"else if (from.placement == StructurePlacementScript('bigglobe:surface_mineshaft/tunnel'):",
						"int rotation = random.nextInt(4) * 90",
						"to.rotateAround(0, 0, rotation)",
						"int offset = int(rotation % 180 == from.rotation % 180)",
						"switch (rotation:",
							"case(  0: to.offset(from.maxX + offset, from.minY, random.nextInt(from.minZ + 2, from.maxZ - 1)))",
							"case( 90: to.offset(random.nextInt(from.minX + 2, from.maxX - 1), from.minY, from.maxZ + offset))",
							"case(180: to.offset(from.minX - offset, from.minY, random.nextInt(from.minZ + 2, from.maxZ - 1)))",
							"case(270: to.offset(random.nextInt(from.minX + 2, from.maxX - 1), from.minY, from.minZ - offset))",
						")",
					")",
					"else (",
						"int rotation = random.nextInt(4) * 90",
						"to.rotateAround(0, 0, rotation)",
						"int y = from.placement == StructurePlacementScript('bigglobe:surface_mineshaft/ladder') && random.nextBoolean() ? from.maxY - 4 : from.minY",
						"switch (rotation:",
							"case(  0: to.offset(from.maxX, y, from.midZ))",
							"case( 90: to.offset(from.midX, y, from.maxZ))",
							"case(180: to.offset(from.minX, y, from.midZ))",
							"case(270: to.offset(from.midX, y, from.minZ))",
						")",
					")",
				")",

				"class ChunkSectionPos(int x int y int z)",
				"HashMap sortedPieces = new()",
				"void addPiece(StructurePiece from, StructurePiece toAdd:",
					"if (",
						"from != null && (",
							"toAdd.maxY >= max_y(toAdd.minX, toAdd.minZ) ||",
							"toAdd.maxY >= max_y(toAdd.minX, toAdd.maxZ) ||",
							"toAdd.maxY >= max_y(toAdd.maxX, toAdd.minZ) ||",
							"toAdd.maxY >= max_y(toAdd.maxX, toAdd.maxZ)",
						")",
					":",
						"return()",
					")",
					"int sectionMinX = toAdd.minX >> 4",
					"int sectionMinY = toAdd.minY >> 4",
					"int sectionMinZ = toAdd.minZ >> 4",
					"int sectionMaxX = toAdd.maxX >> 4",
					"int sectionMaxY = toAdd.maxY >> 4",
					"int sectionMaxZ = toAdd.maxZ >> 4",
					"ChunkSectionPos query = new()",
					"if (from != null:",
						"for (query.x = sectionMinX, query.x <= sectionMaxX, ++query.x:",
							"for (query.y = sectionMinY, query.y <= sectionMaxY, ++query.y:",
								"for (query.z = sectionMinZ, query.z <= sectionMaxZ, ++query.z:",
									"ArrayList potentialIntersections = sortedPieces.(query)",
									"if (potentialIntersections == null: continue())",
									"for (StructurePiece piece in potentialIntersections:",
										"if (",
											"from != piece &&",
											"piece.maxX >= toAdd.minX &&",
											"piece.minX <= toAdd.maxX &&",
											"piece.maxY >= toAdd.minY &&",
											"piece.minY <= toAdd.maxY &&",
											"piece.maxZ >= toAdd.minZ &&",
											"piece.minZ <= toAdd.maxZ",
										":",
											"return()",
										")",
									")",
								")",
							")",
						")",
					")",

					";forced or no intersection. add to sorted cache.",
					"pieces.add(toAdd)",
					"for (int sectionX = sectionMinX, sectionX <= sectionMaxX, ++sectionX:",
						"for (int sectionY = sectionMinY, sectionY <= sectionMaxY, ++sectionY:",
							"for (int sectionZ = sectionMinZ, sectionZ <= sectionMaxZ, ++sectionZ:",
								";(",
									"this is probably one of the most convoluted lines of code I've written so far.",
									"basically what it does is:",
										"1: set the query pos to our loop variables.",
										"2: get the existing list at the query pos, if present.",
										"3: if not present, add a new list to sortedPieces at the query pos.",
											"also, since we just put query into the map,",
											"we don't want to mutate it anymore.",
											"so, replace query with a new ChunkSectionPos at the same time.",
										"4: add toAdd to the list.",
								")",
								"List(sortedPieces.(query.$x(sectionX).$y(sectionY).$z(sectionZ)) ?: (sortedPieces.(query =: new()) := ArrayList.new(4))).add(toAdd)",
							")",
						")",
					")",

					"return()",
				")",

				"int y = ceilInt(max_y(x, z))",
				"Biome biome = getBiome(x, y, z)",
				"WoodPalette palette = (",
					"biome.isIn('bigglobe:has_structure/mega_tree/cherry')",
					"&& random.nextBoolean(0.25)",
					"? WoodPalette('minecraft:cherry')",
					": WoodPalette.randomForBiome(biome)",
				")",
				"if (palette == null: return())",

				"ScriptStructurePiece newPiece(:",
					"NbtCompound nbt = nbtCompound(palette: palette.id)",
					"random.switch(",
						"ScriptStructurePiece.new(",
							"int length = random.nextInt(6, 12),,",
							"0, 2 - length, -2, length, 4, 2,",
							"'bigglobe:surface_mineshaft/staircase',",
							"nbt",
						"),",
						"ScriptStructurePiece.new(",
							"int length = random.nextInt(6, 12),,",
							"0, 0, -2, length, 7, 2,",
							"'bigglobe:surface_mineshaft/tunnel',",
							"nbt",
						"),",
						"ScriptStructurePiece.new(",
							"int height = random.nextInt(6, 12),,",
							"-1, -height, -3, 5, 4, 3,",
							"'bigglobe:surface_mineshaft/ladder',",
							"nbt",
						"),",
						"ScriptStructurePiece.new(",
							"int radiusX = random.nextInt(2, 6),,",
							"int radiusZ = random.nextInt(2, 6),,",
							"int height  = 2 + min(radiusX, radiusZ),,",
							"-1, 0, -radiusZ, radiusX << 1 - 1, height << 1, radiusZ,",
							"'bigglobe:surface_mineshaft/room',",
							"nbt.maxY = height,, nbt",
						")",
					")",
				")",

				"addPiece(",
					"null,",
					"ScriptStructurePiece.new(",
						"int length = random.nextInt(10, 20)",
						"1, 1 - length, -2, length + 1, 3, 2,",
						"'bigglobe:surface_mineshaft/staircase',",
						"nbtCompound(palette: palette.id, start: true)",
					")",
					".rotateAround(0, 0, random.nextInt(4) * 90)",
					".offset(x, y, z)",
				")",
				"if (distantHorizons: return())",

				"int desiredPieces = int(exp(random.nextDouble(log(16.0L), log(256.0L))))",
				"for (int attempt = 0, attempt < 1024 && pieces.size < desiredPieces, ++attempt:",
					"ScriptStructurePiece from = pieces.(random.nextInt(pieces.size))",
					"random.if (((from.midX - x) ^ 2 + (from.midZ - z) ^ 2) / 96.0L ^ 2: continue())",
					"ScriptStructurePiece toAdd = newPiece()",
					"positionPiece(from, toAdd)",
					"addPiece(from, toAdd)",
				")",

				"if (pieces.size == 1: pieces.removeIndex(0))"
			]
		}
	}
}