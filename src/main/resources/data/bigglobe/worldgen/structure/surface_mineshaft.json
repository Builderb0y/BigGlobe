{
	"type": "bigglobe:script",
	"biomes": "#bigglobe:has_structure/surface_mineshaft",
	"spawn_overrides": {},
	"step": "surface_structures",
	"layout": [
		"void positionPiece(ScriptStructurePiece from, ScriptStructurePiece to:",
			"if (from.placement == StructurePlacementScript('bigglobe:surface_mineshaft/staircase'):",
				"to.symmetrifyAround(0, 0, from.symmetry)",
				"switch (from.symmetry:",
					"case(IDENTITY:   to.offset(from.maxX + 1, from.minY, from.midZ    ))",
					"case(ROTATE_90:  to.offset(from.midX,     from.minY, from.maxZ + 1))",
					"case(ROTATE_180: to.offset(from.minX - 1, from.minY, from.midZ    ))",
					"case(ROTATE_270: to.offset(from.midX,     from.minY, from.minZ - 1))",
				")",
			")",
			"else if (from.placement == StructurePlacementScript('bigglobe:surface_mineshaft/tunnel'):",
				"Symmetry symmetry = Symmetry.randomRotation()",
				"to.symmetrifyAround(0, 0, symmetry)",
				"int offset = int(from.symmetry.andThen(symmetry) == Symmetry('IDENTITY'))",
				"switch (symmetry:",
					"case(IDENTITY:   to.offset(from.maxX + offset, from.minY, random.nextInt(from.minZ + 2, from.maxZ - 1)))",
					"case(ROTATE_90:  to.offset(random.nextInt(from.minX + 2, from.maxX - 1), from.minY, from.maxZ + offset))",
					"case(ROTATE_180: to.offset(from.minX - offset, from.minY, random.nextInt(from.minZ + 2, from.maxZ - 1)))",
					"case(ROTATE_270: to.offset(random.nextInt(from.minX + 2, from.maxX - 1), from.minY, from.minZ - offset))",
				")",
			")",
			"else (",
				"Symmetry symmetry = Symmetry.randomRotation()",
				"to.symmetrifyAround(0, 0, symmetry)",
				"int y = from.placement == StructurePlacementScript('bigglobe:surface_mineshaft/ladder') && random.nextBoolean() ? from.maxY - 4 : from.minY",
				"switch (symmetry:",
					"case(IDENTITY:   to.offset(from.maxX, y, from.midZ))",
					"case(ROTATE_90:  to.offset(from.midX, y, from.maxZ))",
					"case(ROTATE_180: to.offset(from.minX, y, from.midZ))",
					"case(ROTATE_270: to.offset(from.midX, y, from.minZ))",
				")",
			")",
		")",

		"boolean StructurePiece.intersects(StructurePiece that:",
			"this.maxX >= that.minX &&",
			"this.minX <= that.maxX &&",
			"this.maxY >= that.minY &&",
			"this.minY <= that.maxY &&",
			"this.maxZ >= that.minZ &&",
			"this.minZ <= that.maxZ",
		")",

		"class ChunkSectionPos(int*(x, y, z))",
		"ChunkSectionPos ChunkSectionPos.at(int*(x, y, z):",
			"this.=$x(x).=$y(y).=$z(z)",
		")",
		"HashMap sortedPieces = new()",
		"void addPiece(StructurePiece from, StructurePiece toAdd:",
			"if (",
				"from != null && (",
					"toAdd.maxY >= `bigglobe:overworld/processed_surface_y`(toAdd.minX, toAdd.minZ) ||",
					"toAdd.maxY >= `bigglobe:overworld/processed_surface_y`(toAdd.minX, toAdd.maxZ) ||",
					"toAdd.maxY >= `bigglobe:overworld/processed_surface_y`(toAdd.maxX, toAdd.minZ) ||",
					"toAdd.maxY >= `bigglobe:overworld/processed_surface_y`(toAdd.maxX, toAdd.maxZ)",
				")",
			":",
				"return()",
			")",
			"int*(",
				"sectionMinX = toAdd.minX >> 4",
				"sectionMinY = toAdd.minY >> 4",
				"sectionMinZ = toAdd.minZ >> 4",
				"sectionMaxX = toAdd.maxX >> 4",
				"sectionMaxY = toAdd.maxY >> 4",
				"sectionMaxZ = toAdd.maxZ >> 4",
			")",
			"ChunkSectionPos query = new()",
			"if (from != null:",
				"for (query.x = sectionMinX, query.x <= sectionMaxX, ++query.x:",
					"for (query.y = sectionMinY, query.y <= sectionMaxY, ++query.y:",
						"for (query.z = sectionMinZ, query.z <= sectionMaxZ, ++query.z:",
							"ArrayList potentialIntersections = sortedPieces.(query)",
							"if (potentialIntersections == null: continue())",
							"for (StructurePiece piece in potentialIntersections:",
								"if (from != piece && piece.intersects(toAdd):",
									"return()",
								")",
							")",
						")",
					")",
				")",
			")",

			";forced or no intersection. add to sorted cache.",
			"pieces.add(toAdd)",
			"for (",
				"int sectionX in range[sectionMinX, sectionMaxX],",
				"int sectionY in range[sectionMinY, sectionMaxY],",
				"int sectionZ in range[sectionMinZ, sectionMaxZ]",
			":",
				";(",
					"this is probably one of the most convoluted lines of code I've written so far.",
					"basically what it does is:",
						"1: set the query pos to our loop variables.",
						"2: get the existing list at the query pos, if present.",
						"3: if not present, add a new list to sortedPieces at the query pos.",
							"also, since we just put query into the map,",
							"we don't want to mutate it anymore.",
							"so, replace query with a new ChunkSectionPos at the same time.",
						"4: add toAdd to the list.",
				")",
				"List(sortedPieces.(query.at(sectionX, sectionY, sectionZ)) ?: (sortedPieces.(query =: new()) := ArrayList.new(4))).add(toAdd)",
			")",

			"return()",
		")",

		"int originY = ceilInt(`bigglobe:overworld/processed_surface_y`)",
		"WoodPalette palette = `bigglobe:overworld/wood_palette` ?: return()",

		"ScriptStructurePiece newPiece(:",
			"NbtCompound nbt = nbtCompound(palette: palette.id)",
			"random.switch(",
				"ScriptStructurePiece.new(",
					"int length = random.nextInt(6, 12),,",
					"0, 2 - length, -2, length, 4, 2,",
					"'bigglobe:surface_mineshaft/staircase',",
					"nbt",
				"),",
				"ScriptStructurePiece.new(",
					"int length = random.nextInt(6, 12),,",
					"0, 0, -2, length, 7, 2,",
					"'bigglobe:surface_mineshaft/tunnel',",
					"nbt",
				"),",
				"ScriptStructurePiece.new(",
					"int height = random.nextInt(6, 12),,",
					"-1, -height, -3, 5, 4, 3,",
					"'bigglobe:surface_mineshaft/ladder',",
					"nbt",
				"),",
				"ScriptStructurePiece.new(",
					"int radiusX = random.nextInt(2, 6),,",
					"int radiusZ = random.nextInt(2, 6),,",
					"int height  = 2 + min(radiusX, radiusZ),,",
					"-1, 0, -radiusZ, radiusX << 1 - 1, height << 1, radiusZ,",
					"'bigglobe:surface_mineshaft/room',",
					"nbt.maxY = height,, nbt",
				")",
			")",
		")",

		"addPiece(",
			"null,",
			"ScriptStructurePiece.new(",
				"int length = random.nextInt(10, 20)",
				"1, 1 - length, -2, length + 1, 3, 2,",
				"'bigglobe:surface_mineshaft/staircase',",
				"nbtCompound(palette: palette.id, start: true)",
			")",
			".symmetrifyAround(0, 0, Symmetry.randomRotation())",
			".offset(originX, originY, originZ)",
		")",

		"int desiredPieces = distantHorizons ? 2 : int(exp(random.nextDouble(log(16.0L), log(256.0L))))",
		"for (int attempt = 0, attempt < 1024 && pieces.size < desiredPieces, ++attempt:",
			"ScriptStructurePiece from = pieces.(random.nextInt(pieces.size))",
			"random.if (((from.midX - originX) ^ 2 + (from.midZ - originZ) ^ 2) / 96.0L ^ 2: continue())",
			"ScriptStructurePiece toAdd = newPiece()",
			"positionPiece(from, toAdd)",
			"addPiece(from, toAdd)",
		")",

		"if (pieces.size == 1: pieces.removeIndex(0))",
		"else if (distantHorizons: pieces.removeIndex(1))"
	]
}