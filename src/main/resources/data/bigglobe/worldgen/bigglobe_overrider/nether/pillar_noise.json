{
	"type": "column_value",
	"script": [
		"for (StructureStart start in structures:",
			"if (start.structure.isIn('bigglobe:nether_pillars'):",
				"for (ScriptStructurePiece piece in start.pieces:",
					"class PillarData (",
						"double*(",
							"posX, posY, posZ,",
							"negX, negY, negZ,",
							"normX, normY, normZ,",
							"length,",
							"endRadius,",
							"centerRadius",
						")",
					")",

					"PillarData pillarData = new(",
						"piece.data.posX.asDouble(),",
						"piece.data.posY.asDouble(),",
						"piece.data.posZ.asDouble(),",
						"piece.data.negX.asDouble(),",
						"piece.data.negY.asDouble(),",
						"piece.data.negZ.asDouble(),",
						"piece.data.normX.asDouble(),",
						"piece.data.normY.asDouble(),",
						"piece.data.normZ.asDouble(),",
						"piece.data.length.asDouble(),",
						"piece.data.endR.asDouble(),",
						"piece.data.centerR.asDouble()",
					")",

					"class Projector (",
						"double*(",
							"relativeX, relativeY, relativeZ,",
							"dotX, dotY, dotZ, dot",
							"projectionX, projectionY, projectionZ,",
							"projectionDistanceSquared",
						")",
					")",

					"Projector Projector.setX(double x:",
						"this.=$dotX((this.relativeX := x - pillarData.negX) * pillarData.normX)",
					")",

					"Projector Projector.setY(double y:",
						"this.=$dotY((this.relativeY := y - pillarData.negY) * pillarData.normY)",
					")",

					"Projector Projector.setZ(double z:",
						"this.=$dotZ((this.relativeZ := z - pillarData.negZ) * pillarData.normZ)",
					")",

					"Projector Projector.project(boolean clamp:",
						"double dot = this.dotX + this.dotY + this.dotZ",
						"if (clamp: dot = clamp(0.0L, pillarData.length, dot))",
						"this.$=dot(dot).$=projectionDistanceSquared(",
							"(this.relativeX - (this.projectionX := dot * pillarData.normX)) ^ 2 +",
							"(this.relativeY - (this.projectionY := dot * pillarData.normY)) ^ 2 +",
							"(this.relativeZ - (this.projectionZ := dot * pillarData.normZ)) ^ 2",
						")",
					")",

					"double Projector.getExpectedRadius(:",
						"mixLinear(pillarData.centerRadius, pillarData.endRadius, (this.dot / pillarData.length * 2.0L - 1.0L) ^ 2)",
					")",

					"double Projector.getRadiusFractionSquared(:",
						"double expectedRadius = this.getExpectedRadius()",
						"return(expectedRadius > 0.0L ? this.projectionDistanceSquared / expectedRadius ^ 2 : -1.0L)",
					")",

					"Projector projector = new().setX(x).setZ(z)",
					";;",
						"my claim is that the function",
						"y -> projector.setY(y).project(false).projectionDistance()",
						"is a hyperbolic function. to prove this, we will look at a",
						"different specialization of a more broad set of problems:",
						"the closest point between 2 arbitrary lines.",

						"say you have 2 lines, line1 and line2,",
						"and a point on each of those lines,",
						"point1 on line1, and point2 on line2.",
						"which pair of points has the smallest distance between them?",

						"for our first simplified case, assume line1",
						"intersects the origin, and is aligned with the x axis.",
						"also assume line2 intersects (0, 1, 0) and is aligned with the z axis.",
						"for any given point2, the closest point to it on line1 will be the origin,",
						"so the distance from point1 to point2 is:",
							"sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2)",
							"= sqrt((0 - 0) ^ 2 + (1 - 0) ^ 2 + (z2 - 0) ^ 2)",
							"= sqrt(0^2 + 1^2 + z2^2)",
							"= sqrt(z2 ^ 2 + 1)",
						"this is a hyperbola, as desired.",

						"what if line2 intersects (0, 1, 0), but is no longer aligned with the z axis?",
						"in this case, the closest point1 to it is (x2, 0, z2).",
						"the distance then, is:",
							"sqrt((x2 - x1) ^ 2 + (y2 - y1) ^ 2 + (z2 - z1) ^ 2)",
							"= sqrt((x2 - x2) ^ 2 + (1 - 0) ^ 2) + (z2 - 0) ^ 2)",
							"= sqrt(0^2 + 1^2 + z2^2)",
							"= sqrt(z2^2 + 1)",
						"the x coordinates cancel each other out, and we still have a hyperbola.",

						"final case: what if line2 intersects a different point besides (0, 1, 0)?",
						"say, for example, (0, 4, 0)",
						"I'll spare you the math, but the end result is:",
							"sqrt(z2^2 + 16)",
						"this is STILL a hyperbola.",

						"to complete this proof, the last assumption we need is that changing",
						"the orientation of space does not change the distance between 2 points.",
						"so, any function which linearly maps a number to a point on line1, and then",
						"point1 to its closest counterpart on line2, must be a hyperbolic function.",

						"so... how does this proof help us figure out which Y levels need to have their noise values modified?",
						"well, a pillar is a line, and a column is also a line.",
						"so by definition, y -> projector.setY(y).project(false).projectionDistance()",
						"is a hyperbolic function.",
						"additionally, y -> projector.setY(y).project(false).projectionDistanceSquared will",
						"be a parabolic function, because a hyperbola is just the square root of a parabola.",
						"a parabolic function of y can be defined as ay^2 + by + c for some constants a, b, and c.",
						"if we can find these constants, then we can directly deduce some properties of the parabola.",
						"in particular, we can deduce its midpoint, and the interval of its domain",
						"which is less than some threshold, by using the quadratic formula.",
						"knowing this interval means we know which Y",
						"levels are within some distance of the pillar.",
						"the distance to the pillar that we need in order to modify",
						"noise at changes based on where along the pillar we are,",
						"but it does have an upper bound: endRadius.",
						"at the very least, this vastly reduces the number of",
						"y levels that we need to check in the first place.",

						"sounds good in theory, but how do we actually find those constants from earlier?",
						"well, we can directly query the parabola function at arbitrary Y levels,",
						"and we only need 3 points to find a parabola which passes through all of them.",
						"we can technically use any 3 points, but -1, 0, and 1 have the simplest math.",
						"the system of equations that arise from these points is as follows:",
							"a * (-1) ^ 2 + b * (-1) + c = (the distance squared at y = -1)",
							"a * 0^2 + b * 0 + c = (the distance squared at y = 0)",
							"a * 1^2 + b * 1 + c = (the distance squared at y = 1)",
						"we have 3 equations, and 3 unknowns,",
						"so this is a system which can be solved.",
						"the solution is given in the code below.",
					";;",
					"double distanceSquaredAtNegativeOne = projector.setY(-1).project(false).projectionDistanceSquared",
					"double distanceSquaredAtZero        = projector.setY( 0).project(false).projectionDistanceSquared",
					"double distanceSquaredAtOne         = projector.setY( 1).project(false).projectionDistanceSquared",

					"double a = (distanceSquaredAtOne + distanceSquaredAtNegativeOne) * 0.5L - distanceSquaredAtZero",
					"double b = (distanceSquaredAtOne - distanceSquaredAtNegativeOne) * 0.5L",
					"double c = distanceSquaredAtZero",

					";;",
						"the interval where the hyperbola is less than endRadius is the",
						"same as the interval where the parabola is less than endRadius ^ 2.",
						"the quadratic formula, (-b +/- sqrt(b^2 - 4ac)) / 2a,",
						"can give the interval where the parabola is less than 0.",
						"to get the interval where the parabola is less than",
						"this.endRadius ^ 2, we simply need to subtract it from c.",
					";;",

					"c -= 4.0L * pillarData.endRadius ^ 2",
					"double sqrtTerm = b ^ 2 - 4.0L * a * c",
					"if (sqrtTerm !> 0.0L: continue()) ;interval is non-existent.",
					"sqrtTerm = sqrt(sqrtTerm)",
					"double div = 0.5L / a",
					"int minY = ceilInt((-b - sqrtTerm) * div)",
					"if (minY >= `bigglobe:nether/max_y`: continue()) ;interval does not intersect the Y range we care about.",
					"int maxY = floorInt((-b + sqrtTerm) * div)",
					"if (maxY < `bigglobe:nether/min_y`: continue()) ;interval does not intersect the Y range we care about.",

					"minY = max(minY, piece.minY, `bigglobe:nether/min_y`)",
					"maxY = min(maxY, piece.maxY, `bigglobe:nether/max_y`)",
					"for (int y in range[minY, maxY]:",
						"double fraction = projector.setY(y).project(true).getRadiusFractionSquared()",
						"if (fraction.isBetween(0.0L, 4.0L):",
							"fraction = abs(fraction * (1.0L / 3.0L) - (4.0L / 3.0L))",
							"`bigglobe:nether/bubble`.noise(y) += float(fraction ^ 3)",
						")",
					")",
				")",
			")",
		")"
	]
}