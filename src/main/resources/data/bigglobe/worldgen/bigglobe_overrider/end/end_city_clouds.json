{
	"type": "column_value",
	"script": [
		"for (StructureStart start in structures:",
			"if (start.structure ==. 'minecraft:end_city':",
				"for (StructurePiece piece in start.pieces:",
					"int clampedX = clamp(piece.minX, piece.maxX, x)",
					"int clampedZ = clamp(piece.minZ, piece.maxZ, z)",
					"int horizontalDistance2 = (x - clampedX) ^ 2 + (z - clampedZ) ^ 2",
					"if (horizontalDistance2 < 16 ^ 2:",
						"if (`bigglobe:end/warp_radius`.isBetween(`bigglobe:end/ring_cloud_min_radius`, `bigglobe:end/ring_cloud_max_radius`):",
							"for (",
								"int y in range[",
									"max(piece.minY - 16,  ceilInt(`bigglobe:end/mountain_center` + `bigglobe:end/ring_cloud_center_offset` - `bigglobe:end/ring_cloud_thickness`)),",
									"min(piece.maxY + 16, floorInt(`bigglobe:end/mountain_center` + `bigglobe:end/ring_cloud_center_offset` + `bigglobe:end/ring_cloud_thickness`))",
								"]",
							":",
								"int clampedY = clamp(piece.minY, piece.maxY, y)",
								"float distance = sqrt(horizontalDistance2 + (y - clampedY) ^ 2).as(float)",
								"`bigglobe:end/upper_ring_cloud_sdf`(y) -= unmixSmooth(16.0I, 0.0I, distance)",
							")",
						")",
						"if (`bigglobe:end/warp_radius` > `bigglobe:end/bridge_cloud_min_radius`:",
							"for (",
								"int y in range[",
									"max(piece.minY - 16,  ceilInt(`bigglobe:end/mountain_center` + `bigglobe:end/bridge_cloud_center_offset` - `bigglobe:end/bridge_cloud_thickness`)),",
									"min(piece.maxY + 16, floorInt(`bigglobe:end/mountain_center` + `bigglobe:end/bridge_cloud_center_offset` + `bigglobe:end/bridge_cloud_thickness`))",
								"]",
							":",
								"int clampedY = clamp(piece.minY, piece.maxY, y)",
								"float distance = sqrt(horizontalDistance2 + (y - clampedY) ^ 2).as(float)",
								"`bigglobe:end/upper_bridge_cloud_sdf`(y) -= unmixSmooth(16.0I, 0.0I, distance)",
							")",
						")",
					")",
				")",
			")",
		")"
	]
}